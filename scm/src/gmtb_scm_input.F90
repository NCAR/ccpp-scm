!> \file gmtb_scm_input.f90
!!  Contains input-related subroutines -- reading in model configuration from file or the command line and reading in the case
!!  initial conditions and forcing; also contains reference profile input (temporarily hard-coded).

module gmtb_scm_input

use gmtb_scm_kinds, only : sp, dp, qp
use netcdf
use gmtb_scm_type_defs, only: character_length

implicit none

integer :: missing_snow_layers = 3
integer :: missing_soil_layers = 4
integer :: missing_ice_layers = 2

contains

!> \ingroup SCM
!! @{
!! \defgroup input gmtb_scm_input
!! @{
!! Contains input-related subroutines -- reading in model configuration from file or the command line and reading in the case
!! initial conditions and forcing; also contains reference profile input (temporarily hard-coded).

!> Subroutine to get basic model configuration data from a namelist file (whose name is specified as the first argument on the command line) and from
!! data entered on the command line with the format: "var1='string' var2=d.d var3=i". Namelist variables listed on the command line
!! override those that are specified in the external namelist file. The case configuration namelist variables are also written out to
!! a namelist file placed in the output directory. Note: This routine uses GET_COMMAND which is an intrinsic routine in the Fortran 2003 standard. This
!! requires that the compiler supports this standard.
subroutine get_config_nml(scm_state)
  use gmtb_scm_type_defs, only : scm_state_type

  type(scm_state_type), target, intent(inout) :: scm_state

  character(len=character_length)    :: experiment_name !< name of the experiment configuration file (usually case name)
  character(len=character_length)    :: model_name !< name of the host model (currently only GFS supported)
  character(len=character_length)    :: case_name !< name of case initialization and forcing dataset
  real(kind=dp)        :: dt !< time step in seconds
  real(kind=dp)        :: runtime !< total runtime in seconds
  real(kind=dp)        :: output_frequency !< freqency of output writing in seconds
  integer              :: n_levels !< number of model levels (currently only 64 supported)
  integer              :: n_soil   !< number of model soil levels (currently only 4 supported)
  integer              :: n_snow   !< number of model snow levels (currently only 3 supported)
  integer              :: n_columns !< number of columns to use
  integer              :: n_time_levels
  integer              :: time_scheme !< 1 => forward Euler, 2 => filtered leapfrog
  character(len=character_length)    :: output_dir !< name of the output directory
  character(len=character_length)    :: output_file !< name of the output file (without the file extension)
  character(len=character_length)    :: case_data_dir !< path to the directory containing case initialization and forcing data
  character(len=character_length)    :: vert_coord_data_dir !< path to the directory containing vertical coordinate data
  integer              :: thermo_forcing_type !< 1: "revealed forcing", 2: "horizontal advective forcing", 3: "relaxation forcing"
  integer              :: mom_forcing_type !< 1: "revealed forcing", 2: "horizontal advective forcing", 3: "relaxation forcing"
  integer              :: C_RES            !< reference "C" resoltiion of FV3 grid (needed for GWD and mountain blocking)
  real(kind=dp)        :: relax_time !< relaxation time scale (s)
  logical              :: sfc_flux_spec !< flag for using specified surface fluxes instead of calling a surface scheme
  real(kind=dp)        :: sfc_roughness_length_cm !< surface roughness length used for calculating surface layer parameters from specified fluxes
  integer              :: sfc_type !< 0: sea surface, 1: land surface, 2: sea-ice surface
  logical              :: model_ics !<  true means have land info too
  integer              :: reference_profile_choice !< 1: McClatchey profile, 2: mid-latitude summer standard atmosphere
  integer              :: year, month, day, hour
  real(kind=dp)        :: column_area

  character(len=character_length)    :: physics_suite !< name of the physics suite name (currently only GFS_operational supported)
  character(len=character_length)    :: physics_nml
  
  character(len=character_length), allocatable, dimension(:) :: tracer_names

  integer                          :: ioerror

  CHARACTER(LEN=*), parameter :: experiment_namelist = 'input_experiment.nml'

  NAMELIST /case_config/ model_name, n_columns, case_name, dt, time_scheme, runtime, output_frequency, &
    n_levels, output_dir, output_file, case_data_dir, vert_coord_data_dir, thermo_forcing_type, model_ics,C_RES,mom_forcing_type, relax_time, &
    sfc_type, sfc_flux_spec, sfc_roughness_length_cm, reference_profile_choice, year, month, day, hour, column_area
    
  NAMELIST /physics_config/ physics_suite, physics_nml

  !>  \section get_config_alg Algorithm
  !!  @{

  !> Define default values for experiment configuration (to be overridden by external namelist file or command line arguments)
  model_name = 'GFS'
  n_columns = 1
  case_name = 'twpice'
  dt = 600.0
  time_scheme = 2
  runtime = 2138400.0
  output_frequency = 600.0
  n_levels = 64
  n_soil   = 4
  n_snow   = 3
  output_dir = 'output'
  output_file = 'output'
  case_data_dir = '../data/processed_case_input'
  vert_coord_data_dir = '../data/vert_coord_data'
  thermo_forcing_type = 2
  mom_forcing_type = 3
  C_RES = 384
  relax_time = 7200.0
  sfc_flux_spec = .false.
  sfc_roughness_length_cm = 1.0
  sfc_type = 0
  model_ics = .false.
  reference_profile_choice = 1
  year = 2006
  month = 1
  day = 19
  hour = 3

  open(unit=10, file=experiment_namelist, status='old', action='read', iostat=ioerror)
  if(ioerror /= 0) then
    write(*,'(a,i0)') 'There was an error opening the file ' // experiment_namelist // &
                      '; error code = ', ioerror
    STOP
  else
    read(10, NML=case_config, iostat=ioerror)
  end if

  if(ioerror /= 0) then
    write(*,'(a,i0)') 'There was an error reading the namelist case_config in the file '&
                      // experiment_namelist // '; error code = ',ioerror
    STOP
  end if

  !The current implementation of GFS physics does not support more than one column, since radiation sub schemes use
  !internal module variables. This means that one cannot specify different ways to treat O3, CO2 etc., and also that
  !the code crashes in GFS_initialize_scm_run and later in radiation_gases.f, because it tries to allocate module
  !variables that are already allocated. For now, throw an error and abort.
  if (n_columns>1) then
    write(*,'(a)') 'The current implementation does not allow to run more than one column at a time.'
    STOP
  end if
  
  !read in the physics suite and namelist
  read(10, NML=physics_config, iostat=ioerror)
  close(10)

  select case(time_scheme)
    case(1)
      n_time_levels = 1
    case(2)
      n_time_levels = 2
    case default
      n_time_levels = 2
  end select
  
  call get_tracers(tracer_names)
  
  call scm_state%create(n_columns, n_levels, n_soil, n_snow, n_time_levels, tracer_names)

  scm_state%experiment_name = experiment_name
  scm_state%model_name = model_name
  scm_state%output_dir = output_dir
  scm_state%case_data_dir = case_data_dir
  scm_state%vert_coord_data_dir = vert_coord_data_dir
  scm_state%output_file = output_file
  scm_state%case_name = case_name
  scm_state%physics_suite_name = physics_suite
  scm_state%physics_nml = physics_nml
  scm_state%area(:) = column_area

  scm_state%n_cols = n_columns
  scm_state%n_levels = n_levels
  scm_state%n_time_levels = n_time_levels
  scm_state%dt = dt
  scm_state%runtime = runtime
  scm_state%time_scheme = time_scheme
  scm_state%init_year = year
  scm_state%init_month = month
  scm_state%init_day = day
  scm_state%init_hour = hour

  scm_state%output_frequency = output_frequency
  scm_state%thermo_forcing_type = thermo_forcing_type
  scm_state%mom_forcing_type = mom_forcing_type
  scm_state%C_RES            = C_RES            
  scm_state%sfc_flux_spec = sfc_flux_spec
  scm_state%sfc_roughness_length_cm(:) = sfc_roughness_length_cm
  scm_state%sfc_type = REAL(sfc_type, kind=dp)
  scm_state%model_ics = model_ics
  scm_state%reference_profile_choice = reference_profile_choice
  scm_state%relax_time = relax_time
  
  deallocate(tracer_names)
!> @}
end subroutine get_config_nml


!> Subroutine to read the netCDF file containing case initialization and forcing. The forcing files (netCDF4) should be located in the
!! "processed_case_input" directory.
subroutine get_case_init(scm_state, scm_input)
  use gmtb_scm_type_defs, only : scm_state_type, scm_input_type
  use NetCDF_read, only: NetCDF_read_var, check, missing_value
  type(scm_state_type), intent(in) :: scm_state
  type(scm_input_type), target, intent(inout) :: scm_input
  
  integer               :: input_nlev !< number of levels in the input file
  integer               :: input_nsoil !< number of soil levels in the input file
  integer               :: input_ntimes !< number of times represented in the input file
  integer               :: input_nsnow !< number of snow levels in the input file
  integer               :: input_nice !< number of sea ice levels in the input file
  integer               :: input_nsoil_plus_nsnow !< number of combined snow and soil levels in the input file

  ! dimension variables
  real(kind=dp), allocatable  :: input_pres(:) !< input file pressure levels (Pa)
  real(kind=dp), allocatable  :: input_time(:) !< input file times (seconds since the beginning of the case)

  !initial profile variables
  real(kind=dp), allocatable  :: input_thetail(:) !< ice-liquid water potential temperature profile (K)
  real(kind=dp), allocatable  :: input_temp(:) !< temperature profile (K)
  real(kind=dp), allocatable  :: input_qt(:) !< total water specific humidity profile (kg kg^-1)
  real(kind=dp), allocatable  :: input_ql(:) !< liquid water specific humidity profile (kg kg^-1)
  real(kind=dp), allocatable  :: input_qi(:) !< ice water specific humidity profile (kg kg^-1)
  real(kind=dp), allocatable  :: input_u(:) !< east-west horizontal wind profile (m s^-1)
  real(kind=dp), allocatable  :: input_v(:) !< north-south horizontal wind profile (m s^-1)
  real(kind=dp), allocatable  :: input_tke(:) !< TKE profile (m^2 s^-2)
  real(kind=dp), allocatable  :: input_ozone(:) !< ozone profile (kg kg^-1)
! additional land info
  real(kind=dp), allocatable  :: input_stc(:) !< soil temperature (K)
  real(kind=dp), allocatable  :: input_smc(:) !< total soil moisture content (fraction)  
  real(kind=dp), allocatable  :: input_slc(:) !< liquid soil moisture content (fraction)
  !real(kind=dp), allocatable  :: input_pres_i(:) !< interface pressures
  !real(kind=dp), allocatable  :: input_pres_l(:) !< layer pressures
  real(kind=dp), allocatable  :: input_snicexy(:) !< snow layer ice (mm)
  real(kind=dp), allocatable  :: input_snliqxy(:) !< snow layer liquid (mm)
  real(kind=dp), allocatable  :: input_tsnoxy(:) !< snow temperature (K)
  real(kind=dp), allocatable  :: input_smoiseq(:) !< equilibrium soil water content (m3 m-3)
  real(kind=dp), allocatable  :: input_zsnsoxy(:) !< layer bottom depth from snow surface (m)
  real(kind=dp), allocatable  :: input_tiice(:)   !< sea ice internal temperature (K)
  real(kind=dp), allocatable  :: input_tslb(:)    !< soil temperature for RUC LSM (K)
  real(kind=dp), allocatable  :: input_smois(:)   !< volume fraction of soil moisture for RUC LSM (frac)
  real(kind=dp), allocatable  :: input_sh2o(:)    !< volume fraction of unfrozen soil moisture for RUC LSM (frac)
  real(kind=dp), allocatable  :: input_smfr(:)    !< volume fraction of frozen soil moisture for RUC LSM (frac)
  real(kind=dp), allocatable  :: input_flfr(:)    !< flag for frozen soil physics
  
  integer                     :: input_vegsrc !< vegetation source
  integer                     :: input_vegtyp !< vegetation type
  integer                     :: input_soiltyp!< soil type
  integer                     :: input_slopetype !< slope type
  real(kind=dp)               :: input_lat !< column latitude (deg)
  real(kind=dp)               :: input_lon !< column longitude (deg)
  real(kind=dp)               :: input_tsfco !< input sea surface temperature OR surface skin temperature over land OR surface skin temperature over ice (depending on slmsk) (K)
  real(kind=dp)               :: input_vegfrac  !< vegetation fraction
  real(kind=dp)               :: input_shdmin  !< minimun vegetation fraction
  real(kind=dp)               :: input_shdmax  !< maximun vegetation fraction
  real(kind=dp)               :: input_zorlo    !< surfce roughness length over ocean [cm]
  real(kind=dp)               :: input_slmsk   !< sea land ice mask [0,1,2]
  real(kind=dp)               :: input_canopy  !< amount of water stored in canopy (kg m-2)
  real(kind=dp)               :: input_hice    !< sea ice thickness (m)
  real(kind=dp)               :: input_fice    !< ice fraction (frac)
  real(kind=dp)               :: input_tisfc   !< ice surface temperature (K)
  real(kind=dp)               :: input_snwdph  !< water equivalent snow depth (mm)
  real(kind=dp)               :: input_snoalb  !< maximum snow albedo (frac)
  real(kind=dp)               :: input_sncovr  !< snow area fraction (frac)
  real(kind=dp)               :: input_area    !< surface area [m^2]
  real(kind=dp)               :: input_tg3     !< deep soil temperature (K)
  real(kind=dp)               :: input_uustar  !< surface friction velocity (m s-1)
  real(kind=dp)               :: input_alvsf !< 60 degree vis albedo with strong cosz dependency
  real(kind=dp)               :: input_alnsf !< 60 degree nir albedo with strong cosz dependency
  real(kind=dp)               :: input_alvwf !< 60 degree vis albedo with weak cosz dependency
  real(kind=dp)               :: input_alnwf !< 60 degree nir albedo with weak cosz dependency
  real(kind=dp)               :: input_facsf !< fractional coverage with strong cosz dependency
  real(kind=dp)               :: input_facwf !< fractional coverage with weak cosz dependency
  real(kind=dp)               :: input_weasd !< water equivalent accumulated snow depth (mm)
  real(kind=dp)               :: input_f10m  !< ratio of sigma level 1 wind and 10m wind
  real(kind=dp)               :: input_t2m    !< 2-meter absolute temperature (K)
  real(kind=dp)               :: input_q2m    !< 2-meter specific humidity (kg kg-1)
  real(kind=dp)               :: input_ffmm    !< Monin-Obukhov similarity function for momentum
  real(kind=dp)               :: input_ffhh    !< Monin-Obukhov similarity function for heat
  real(kind=dp)               :: input_tprcp   !< instantaneous total precipitation amount (m)
  real(kind=dp)               :: input_srflag  !< snow/rain flag for precipitation
  real(kind=dp)               :: input_tsfcl   !< surface skin temperature over land (K)
  real(kind=dp)               :: input_zorll   !< surface roughness length over land (cm)
  real(kind=dp)               :: input_zorli   !< surface roughness length over ice (cm)
  real(kind=dp)               :: input_zorlw   !< surface roughness length from wave model (cm)
  
  real(kind=dp)               :: input_stddev !< standard deviation of subgrid orography (m)
  real(kind=dp)               :: input_convexity !< convexity of subgrid orography 
  real(kind=dp)               :: input_ol1 !< fraction of grid box with subgrid orography higher than critical height 1
  real(kind=dp)               :: input_ol2 !< fraction of grid box with subgrid orography higher than critical height 2
  real(kind=dp)               :: input_ol3 !< fraction of grid box with subgrid orography higher than critical height 3
  real(kind=dp)               :: input_ol4 !< fraction of grid box with subgrid orography higher than critical height 4
  real(kind=dp)               :: input_oa1 !< assymetry of subgrid orography 1
  real(kind=dp)               :: input_oa2 !< assymetry of subgrid orography 2
  real(kind=dp)               :: input_oa3 !< assymetry of subgrid orography 3
  real(kind=dp)               :: input_oa4 !< assymetry of subgrid orography 4
  real(kind=dp)               :: input_sigma !< slope of subgrid orography
  real(kind=dp)               :: input_theta !< angle with respect to east of maximum subgrid orographic variations (deg)
  real(kind=dp)               :: input_gamma !< anisotropy of subgrid orography
  real(kind=dp)               :: input_elvmax!< maximum of subgrid orography (m)
  real(kind=dp)               :: input_oro !< orography (m)
  real(kind=dp)               :: input_oro_uf !< unfiltered orography (m)
  real(kind=dp)               :: input_landfrac !< fraction of horizontal grid area occupied by land
  real(kind=dp)               :: input_lakefrac !< fraction of horizontal grid area occupied by lake
  real(kind=dp)               :: input_lakedepth !< lake depth (m)
  
  real(kind=dp)               :: input_tvxy !< vegetation temperature (K)
  real(kind=dp)               :: input_tgxy !< ground temperature for Noahmp (K)
  real(kind=dp)               :: input_tahxy !< canopy air temperature (K)
  real(kind=dp)               :: input_canicexy !< canopy intercepted ice mass (mm)
  real(kind=dp)               :: input_canliqxy !< canopy intercepted liquid water (mm)
  real(kind=dp)               :: input_eahxy !< canopy air vapor pressure (Pa)
  real(kind=dp)               :: input_cmxy !< surface drag coefficient for momentum for noahmp
  real(kind=dp)               :: input_chxy !< surface exchange coeff heat & moisture for noahmp
  real(kind=dp)               :: input_fwetxy !< area fraction of canopy that is wetted/snowed
  real(kind=dp)               :: input_sneqvoxy !< snow mass at previous time step (mm)
  real(kind=dp)               :: input_alboldxy !< snow albedo at previous time step (frac)
  real(kind=dp)               :: input_qsnowxy !< snow precipitation rate at surface (mm s-1)
  real(kind=dp)               :: input_wslakexy !< lake water storage (mm)
  real(kind=dp)               :: input_taussxy !< non-dimensional snow age
  real(kind=dp)               :: input_waxy !< water storage in aquifer (mm)
  real(kind=dp)               :: input_wtxy !< water storage in aquifer and saturated soil (mm)
  real(kind=dp)               :: input_zwtxy !< water table depth (m)
  real(kind=dp)               :: input_xlaixy !< leaf area index
  real(kind=dp)               :: input_xsaixy !< stem area index
  real(kind=dp)               :: input_lfmassxy !< leaf mass (g m-2)
  real(kind=dp)               :: input_stmassxy !< stem mass (g m-2)
  real(kind=dp)               :: input_rtmassxy !< fine root mass (g m-2)
  real(kind=dp)               :: input_woodxy !< wood mass including woody roots (g m-2)
  real(kind=dp)               :: input_stblcpxy !< stable carbon in deep soil (g m-2)
  real(kind=dp)               :: input_fastcpxy !< short-lived carbon in shallow soil (g m-2)
  real(kind=dp)               :: input_smcwtdxy !< soil water content between the bottom of the soil and the water table (m3 m-3)
  real(kind=dp)               :: input_deeprechxy !< recharge to or from the water table when deep (m)
  real(kind=dp)               :: input_rechxy !< recharge to or from the water table when shallow (m)
  real(kind=dp)               :: input_snowxy !< number of snow layers

  real(kind=dp)               :: input_tref !< sea surface reference temperature for NSST (K)
  real(kind=dp)               :: input_z_c !< sub-layer cooling thickness for NSST (m)
  real(kind=dp)               :: input_c_0 !< coefficient 1 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_c_d !< coefficient 2 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_w_0 !< coefficient 3 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_w_d !< coefficient 4 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_xt !< heat content in diurnal thermocline layer for NSST (K m)
  real(kind=dp)               :: input_xs !< salinity content in diurnal thermocline layer for NSST (ppt m)
  real(kind=dp)               :: input_xu !< u-current in diurnal thermocline layer for NSST (m2 s-1)
  real(kind=dp)               :: input_xv !< v-current in diurnal thermocline layer for NSST (m2 s-1)
  real(kind=dp)               :: input_xz !< thickness of diurnal thermocline layer for NSST (m)
  real(kind=dp)               :: input_zm !< thickness of ocean mixed layer for NSST (m)
  real(kind=dp)               :: input_xtts !< sensitivity of diurnal thermocline layer heat content to surface temperature [d(xt)/d(ts)] for NSST (m)
  real(kind=dp)               :: input_xzts !< sensitivity of diurnal thermocline layer thickness to surface temperature [d(xz)/d(ts)] for NSST (m K-1)
  real(kind=dp)               :: input_d_conv !< thickness of free convection layer for NSST (m)
  real(kind=dp)               :: input_ifd !< index to start DTM run for NSST
  real(kind=dp)               :: input_dt_cool !< sub-layer cooling amount for NSST (K)
  real(kind=dp)               :: input_qrain !< sensible heat due to rainfall for NSST (W)
  
  real(kind=dp)               :: input_wetness !< normalized soil wetness for RUC LSM
  real(kind=dp)               :: input_clw_surf !< cloud condensed water mixing ratio at surface for RUC LSM (kg kg-1)
  real(kind=dp)               :: input_qwv_surf !< water vapor mixing ratio at surface for RUC LSM (kg kg-1)
  real(kind=dp)               :: input_tsnow !< snow temperature at the bottom of the first snow layer for RUC LSM (K)
  real(kind=dp)               :: input_snowfallac !< run-total snow accumulation on the ground for RUC LSM (kg m-2)
  real(kind=dp)               :: input_acsnow !< snow water equivalent of run-total frozen precip for RUC LSM (kg m-2)
  real(kind=dp)               :: input_lai !< leaf area index for RUC LSM
  
  !surface time-series variables
  real(kind=dp), allocatable  :: input_pres_surf(:) !< time-series of surface pressure (Pa)
  real(kind=dp), allocatable  :: input_T_surf(:) !< time-series of surface temperature (K)
  real(kind=dp), allocatable  :: input_sh_flux_sfc(:) !< time-series of surface sensible heat flux (K m s^-1)
  real(kind=dp), allocatable  :: input_lh_flux_sfc(:) !< time-series of surface latent heat flux (kg kg^-1 m s^-1)

  !2D (time, pressure) variables
  real(kind=dp), allocatable  :: input_w_ls(:,:) !< 2D vertical velocity (m s^-1)
  real(kind=dp), allocatable  :: input_omega(:,:) !< 2D pressure vertical velocity (Pa s^-1)
  real(kind=dp), allocatable  :: input_u_g(:,:) !< 2D geostrophic east-west wind (m s^-1)
  real(kind=dp), allocatable  :: input_v_g(:,:) !< 2D geostrophic north-south wind (m s^-1)
  real(kind=dp), allocatable  :: input_u_nudge(:,:) !< 2D nudging east-west wind (m s^-1)
  real(kind=dp), allocatable  :: input_v_nudge(:,:) !< 2D nudging north-south wind (m s^-1)
  real(kind=dp), allocatable  :: input_T_nudge(:,:) !< 2D nudging abs. temperature (K)
  real(kind=dp), allocatable  :: input_thil_nudge(:,:) !< 2D nudging liq. pot. temperature (K)
  real(kind=dp), allocatable  :: input_qt_nudge(:,:) !< 2D nudging specific humidity (kg kg^-1)
  real(kind=dp), allocatable  :: input_dT_dt_rad(:,:) !< 2D radiative heating rate (K s^-1)
  real(kind=dp), allocatable  :: input_h_advec_thetail(:,:) !< 2D theta_il tendency due to large-scale horizontal advection (K s^-1)
  real(kind=dp), allocatable  :: input_h_advec_qt(:,:) !< 2D q_t tendency due to large-scale horizontal advection (kg kg^-1 s^-1)
  real(kind=dp), allocatable  :: input_v_advec_thetail(:,:) !< 2D theta_il tendency due to large-scale vertical advection (K s^-1)
  real(kind=dp), allocatable  :: input_v_advec_qt(:,:) !< 2D q_t tendency due to large-scale horizontal vertical (kg kg^-1 s^-1)

  CHARACTER(LEN=nf90_max_name)      :: tmpName
  integer                           :: ncid, varID, grp_ncid, allocate_status,ierr
  real(kind=dp)                     :: nc_missing_value

  !>  \section get_case_init_alg Algorithm
  !!  @{

  !> - Open the case input file found in the processed_case_input dir corresponding to the experiment name.
  call check(NF90_OPEN(trim(adjustl(scm_state%case_data_dir))//'/'//trim(adjustl(scm_state%case_name))//'.nc',nf90_nowrite,ncid))
  
  !> - Read in missing value from file (replace module variable if present)
  ierr = NF90_GET_ATT(ncid, NF90_GLOBAL, 'missing_value', nc_missing_value)
  if(ierr == NF90_NOERR) then
    missing_value = nc_missing_value
  end if
  
  !> - Get the dimensions (global group).
  
  !required dimensions
  call check(NF90_INQ_DIMID(ncid,"levels",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nlev))
  call check(NF90_INQ_DIMID(ncid,"time",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_ntimes))
  
  !possible dimensions (if using model ICs)
  ierr = NF90_INQ_DIMID(ncid,"nsoil",varID)
  if(ierr /= NF90_NOERR) then
    input_nsoil = missing_soil_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nsoil))
  end if
  ierr = NF90_INQ_DIMID(ncid,"nsnow",varID)
  if(ierr /= NF90_NOERR) then
    input_nsnow = missing_snow_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nsnow))
  end if
  ierr = NF90_INQ_DIMID(ncid,"nice",varID)
  if(ierr /= NF90_NOERR) then
    input_nice = missing_ice_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nice))
  end if  
  
  !> - Allocate the dimension variables.
  allocate(input_pres(input_nlev),input_time(input_ntimes), stat=allocate_status)

  !> - Read in the dimension variables (required).
  call NetCDF_read_var(ncid, "levels", .True., input_pres)
  call NetCDF_read_var(ncid, "time", .True., input_time)

  !> - Read in the initial conditions.

  !>  - Find group ncid for initial group.
  call check(NF90_INQ_GRP_NCID(ncid,"initial",grp_ncid))

  !>  - Allocate the initial profiles (required). One of thetail or temp is required.
  allocate(input_thetail(input_nlev), input_temp(input_nlev), input_qt(input_nlev), input_ql(input_nlev), input_qi(input_nlev), &
    input_u(input_nlev), input_v(input_nlev), input_tke(input_nlev), input_ozone(input_nlev), stat=allocate_status)
  
  !>  - Read in the initial profiles. The variable names in all input files are expected to be identical.
  
  !Either thetail or T must be present
  call NetCDF_read_var(grp_ncid, "thetail", .False., input_thetail)
  call NetCDF_read_var(grp_ncid, "temp", .False., input_temp)
  if (maxval(input_thetail) < 0 .and. maxval(input_temp) < 0) then
    write(*,*) "One of thetail or temp variables must be present in ",trim(adjustl(scm_state%case_name))//'.nc',". Stopping..."
    STOP
  end if
  call NetCDF_read_var(grp_ncid, "qt",    .True., input_qt   )
  call NetCDF_read_var(grp_ncid, "ql",    .True., input_ql   )
  call NetCDF_read_var(grp_ncid, "qi",    .True., input_qi   )
  call NetCDF_read_var(grp_ncid, "u",     .True., input_u    )
  call NetCDF_read_var(grp_ncid, "v",     .True., input_v    )
  call NetCDF_read_var(grp_ncid, "tke",   .True., input_tke  )
  call NetCDF_read_var(grp_ncid, "ozone", .True., input_ozone)
  
  !possible initial profiles
  !needed for Noah LSM and others (when running with model ICs)
  allocate(input_stc(input_nsoil), input_smc(input_nsoil), input_slc(input_nsoil), &
           stat=allocate_status)
  call NetCDF_read_var(grp_ncid, "stc", .False., input_stc)
  call NetCDF_read_var(grp_ncid, "smc", .False., input_smc)
  call NetCDF_read_var(grp_ncid, "slc", .False., input_slc)
  
  !needed for NoahMP LSM (when running with model ICs)
  allocate(input_snicexy(input_nsnow), input_snliqxy(input_nsnow), input_tsnoxy(input_nsnow), &
     input_smoiseq(input_nsoil), input_zsnsoxy(input_nsnow + input_nsoil))
  call NetCDF_read_var(grp_ncid, "snicexy", .False., input_snicexy)
  call NetCDF_read_var(grp_ncid, "snliqxy", .False., input_snliqxy)
  call NetCDF_read_var(grp_ncid, "tsnoxy",  .False., input_tsnoxy )
  call NetCDF_read_var(grp_ncid, "smoiseq", .False., input_smoiseq)
  call NetCDF_read_var(grp_ncid, "zsnsoxy", .False., input_zsnsoxy)
  
  !needed for fractional grid (when running with model ICs)
  allocate(input_tiice(input_nice))
  call NetCDF_read_var(grp_ncid, "tiice", .False., input_tiice)
  
  !needed for RUC LSM (when running with model ICs)
  allocate(input_tslb(input_nsoil), input_smois(input_nsoil), input_sh2o(input_nsoil), &
      input_smfr(input_nsoil), input_flfr(input_nsoil))
  call NetCDF_read_var(grp_ncid, "tslb",  .False., input_tslb )
  call NetCDF_read_var(grp_ncid, "smois", .False., input_smois)
  call NetCDF_read_var(grp_ncid, "sh2o",  .False., input_sh2o )
  call NetCDF_read_var(grp_ncid, "smfr",  .False., input_smfr )
  call NetCDF_read_var(grp_ncid, "flfr",  .False., input_flfr )
  
  !>  - Find group ncid for scalar group.
  call check(NF90_INQ_GRP_NCID(ncid,"scalars",grp_ncid))
  
  !required
  call NetCDF_read_var(grp_ncid, "lat", .True., input_lat)
  call NetCDF_read_var(grp_ncid, "lon", .True., input_lon)
  !time data and area in file ignored?
  call NetCDF_read_var(grp_ncid, "area", .False., input_area)
  
  !possible scalars
  !Noah LSM parameters (when running with model ICs)
  call NetCDF_read_var(grp_ncid, "vegsrc",   .False., input_vegsrc   )
  call NetCDF_read_var(grp_ncid, "vegtyp",   .False., input_vegtyp   )
  call NetCDF_read_var(grp_ncid, "soiltyp",  .False., input_soiltyp  )
  call NetCDF_read_var(grp_ncid, "slopetyp", .False., input_slopetype)
  call NetCDF_read_var(grp_ncid, "tsfco",   .False., input_tsfco)
  call NetCDF_read_var(grp_ncid, "vegfrac", .False., input_vegfrac)
  call NetCDF_read_var(grp_ncid, "shdmin",  .False., input_shdmin)
  call NetCDF_read_var(grp_ncid, "shdmax",  .False., input_shdmax)
  call NetCDF_read_var(grp_ncid, "zorlo",   .False., input_zorlo)
  call NetCDF_read_var(grp_ncid, "slmsk",   .False., input_slmsk)
  call NetCDF_read_var(grp_ncid, "canopy",  .False., input_canopy)
  call NetCDF_read_var(grp_ncid, "hice",    .False., input_hice)
  call NetCDF_read_var(grp_ncid, "fice",    .False., input_fice)
  call NetCDF_read_var(grp_ncid, "tisfc",   .False., input_tisfc)
  call NetCDF_read_var(grp_ncid, "snwdph",  .False., input_snwdph)
  call NetCDF_read_var(grp_ncid, "snoalb",  .False., input_snoalb)
  call NetCDF_read_var(grp_ncid, "tg3",     .False., input_tg3)
  call NetCDF_read_var(grp_ncid, "uustar",  .False., input_uustar)
  call NetCDF_read_var(grp_ncid, "alvsf",   .False., input_alvsf)
  call NetCDF_read_var(grp_ncid, "alnsf",   .False., input_alnsf)
  call NetCDF_read_var(grp_ncid, "alvwf",   .False., input_alvwf)
  call NetCDF_read_var(grp_ncid, "alnwf",   .False., input_alnwf)
  call NetCDF_read_var(grp_ncid, "facsf",   .False., input_facsf)
  call NetCDF_read_var(grp_ncid, "facwf",   .False., input_facwf)
  call NetCDF_read_var(grp_ncid, "weasd",   .False., input_weasd)
  call NetCDF_read_var(grp_ncid, "f10m",    .False., input_f10m)
  call NetCDF_read_var(grp_ncid, "t2m",     .False., input_t2m)
  call NetCDF_read_var(grp_ncid, "q2m",     .False., input_q2m)
  call NetCDF_read_var(grp_ncid, "ffmm",    .False., input_ffmm)
  call NetCDF_read_var(grp_ncid, "ffhh",    .False., input_ffhh)
  call NetCDF_read_var(grp_ncid, "tprcp",   .False., input_tprcp)
  call NetCDF_read_var(grp_ncid, "srflag",  .False., input_srflag)
  call NetCDF_read_var(grp_ncid, "sncovr",  .False., input_sncovr)
  call NetCDF_read_var(grp_ncid, "tsfcl",   .False., input_tsfcl)
  call NetCDF_read_var(grp_ncid, "zorll",   .False., input_zorll)
  call NetCDF_read_var(grp_ncid, "zorli",   .False., input_zorli)
  call NetCDF_read_var(grp_ncid, "zorlw",   .False., input_zorlw)
  
  !orographic parameters
  call NetCDF_read_var(grp_ncid, "stddev",    .False., input_stddev)
  call NetCDF_read_var(grp_ncid, "convexity", .False., input_convexity)
  call NetCDF_read_var(grp_ncid, "oa1",       .False., input_oa1)
  call NetCDF_read_var(grp_ncid, "oa2",       .False., input_oa2)
  call NetCDF_read_var(grp_ncid, "oa3",       .False., input_oa3)
  call NetCDF_read_var(grp_ncid, "oa4",       .False., input_oa4)
  call NetCDF_read_var(grp_ncid, "ol1",       .False., input_ol1)
  call NetCDF_read_var(grp_ncid, "ol2",       .False., input_ol2)
  call NetCDF_read_var(grp_ncid, "ol3",       .False., input_ol3)
  call NetCDF_read_var(grp_ncid, "ol4",       .False., input_ol4)
  call NetCDF_read_var(grp_ncid, "theta",     .False., input_theta)
  call NetCDF_read_var(grp_ncid, "gamma",     .False., input_gamma)
  call NetCDF_read_var(grp_ncid, "sigma",     .False., input_sigma)
  call NetCDF_read_var(grp_ncid, "elvmax",    .False., input_elvmax)
  call NetCDF_read_var(grp_ncid, "oro",       .False., input_oro)
  call NetCDF_read_var(grp_ncid, "oro_uf",    .False., input_oro_uf)
  call NetCDF_read_var(grp_ncid, "landfrac",  .False., input_landfrac)
  call NetCDF_read_var(grp_ncid, "lakefrac",  .False., input_lakefrac)
  call NetCDF_read_var(grp_ncid, "lakedepth", .False., input_lakedepth)
  
  !NoahMP parameters
  call NetCDF_read_var(grp_ncid, "tvxy",      .False., input_tvxy)
  call NetCDF_read_var(grp_ncid, "tgxy",      .False., input_tgxy)
  call NetCDF_read_var(grp_ncid, "tahxy",     .False., input_tahxy)
  call NetCDF_read_var(grp_ncid, "canicexy",  .False., input_canicexy)
  call NetCDF_read_var(grp_ncid, "canliqxy",  .False., input_canliqxy)
  call NetCDF_read_var(grp_ncid, "eahxy",     .False., input_eahxy)
  call NetCDF_read_var(grp_ncid, "cmxy",      .False., input_cmxy)
  call NetCDF_read_var(grp_ncid, "chxy",      .False., input_chxy)
  call NetCDF_read_var(grp_ncid, "fwetxy",    .False., input_fwetxy)
  call NetCDF_read_var(grp_ncid, "sneqvoxy",  .False., input_sneqvoxy)
  call NetCDF_read_var(grp_ncid, "alboldxy",  .False., input_alboldxy)
  call NetCDF_read_var(grp_ncid, "qsnowxy",   .False., input_qsnowxy)
  call NetCDF_read_var(grp_ncid, "wslakexy",  .False., input_wslakexy)
  call NetCDF_read_var(grp_ncid, "taussxy",   .False., input_taussxy)
  call NetCDF_read_var(grp_ncid, "waxy",      .False., input_waxy)
  call NetCDF_read_var(grp_ncid, "wtxy",      .False., input_wtxy)
  call NetCDF_read_var(grp_ncid, "zwtxy",     .False., input_zwtxy)
  call NetCDF_read_var(grp_ncid, "xlaixy",    .False., input_xlaixy)
  call NetCDF_read_var(grp_ncid, "xsaixy",    .False., input_xsaixy)
  call NetCDF_read_var(grp_ncid, "lfmassxy",  .False., input_lfmassxy)
  call NetCDF_read_var(grp_ncid, "stmassxy",  .False., input_stmassxy)
  call NetCDF_read_var(grp_ncid, "rtmassxy",  .False., input_rtmassxy)
  call NetCDF_read_var(grp_ncid, "woodxy",    .False., input_woodxy)
  call NetCDF_read_var(grp_ncid, "stblcpxy",  .False., input_stblcpxy)
  call NetCDF_read_var(grp_ncid, "fastcpxy",  .False., input_fastcpxy)
  call NetCDF_read_var(grp_ncid, "smcwtdxy",  .False., input_smcwtdxy)
  call NetCDF_read_var(grp_ncid, "deeprechxy",.False., input_deeprechxy)
  call NetCDF_read_var(grp_ncid, "rechxy",    .False., input_rechxy)
  call NetCDF_read_var(grp_ncid, "snowxy",    .False., input_snowxy)
  
  !NSST variables
  call NetCDF_read_var(grp_ncid, "tref",    .False., input_tref)
  call NetCDF_read_var(grp_ncid, "z_c",     .False., input_z_c)
  call NetCDF_read_var(grp_ncid, "c_0",     .False., input_c_0)
  call NetCDF_read_var(grp_ncid, "c_d",     .False., input_c_d)
  call NetCDF_read_var(grp_ncid, "w_0",     .False., input_w_0)
  call NetCDF_read_var(grp_ncid, "w_d",     .False., input_w_d)
  call NetCDF_read_var(grp_ncid, "xt",      .False., input_xt)
  call NetCDF_read_var(grp_ncid, "xs",      .False., input_xs)
  call NetCDF_read_var(grp_ncid, "xu",      .False., input_xu)
  call NetCDF_read_var(grp_ncid, "xv",      .False., input_xv)
  call NetCDF_read_var(grp_ncid, "xz",      .False., input_xz)
  call NetCDF_read_var(grp_ncid, "zm",      .False., input_zm)
  call NetCDF_read_var(grp_ncid, "xtts",    .False., input_xtts)
  call NetCDF_read_var(grp_ncid, "xzts",    .False., input_xzts)
  call NetCDF_read_var(grp_ncid, "d_conv",  .False., input_d_conv)
  call NetCDF_read_var(grp_ncid, "ifd",     .False., input_ifd)
  call NetCDF_read_var(grp_ncid, "dt_cool", .False., input_dt_cool)
  call NetCDF_read_var(grp_ncid, "qrain",   .False., input_qrain)
  
  !RUC LSM variables
  call NetCDF_read_var(grp_ncid, "wetness",          .False., input_wetness)
  call NetCDF_read_var(grp_ncid, "clw_surf",         .False., input_clw_surf)
  call NetCDF_read_var(grp_ncid, "qwv_surf",         .False., input_qwv_surf)
  call NetCDF_read_var(grp_ncid, "tsnow",            .False., input_tsnow)
  call NetCDF_read_var(grp_ncid, "snowfall_acc",     .False., input_snowfallac)
  call NetCDF_read_var(grp_ncid, "swe_snowfall_acc", .False., input_acsnow)
  call NetCDF_read_var(grp_ncid, "lai",              .False., input_lai)
    
  !> - Read in the forcing data.

  !>  - Find group ncid for forcing group.
  call check(NF90_INQ_GRP_NCID(ncid,"forcing",grp_ncid))

  !>  - (Recall that multidimensional arrays need to be read in with the order of dimensions reversed from the netCDF file).

  !>  - Allocate the time-series and 2D forcing data.
  allocate(input_pres_surf(input_ntimes), input_T_surf(input_ntimes),            &
    input_sh_flux_sfc(input_ntimes), input_lh_flux_sfc(input_ntimes), input_w_ls(input_ntimes, input_nlev), &
    input_omega(input_ntimes, input_nlev), input_u_g(input_ntimes, input_nlev), input_v_g(input_ntimes, input_nlev), &
    input_dT_dt_rad(input_ntimes, input_nlev), input_h_advec_thetail(input_ntimes, input_nlev), &
    input_h_advec_qt(input_ntimes, input_nlev), input_v_advec_thetail(input_ntimes, input_nlev), &
    input_v_advec_qt(input_ntimes, input_nlev), input_u_nudge(input_ntimes, input_nlev), input_v_nudge(input_ntimes, input_nlev),  &
    input_T_nudge(input_ntimes, input_nlev), input_thil_nudge(input_ntimes, input_nlev), input_qt_nudge(input_ntimes, input_nlev), &
    stat=allocate_status)

  !>  - Read in the time-series and 2D forcing data.
  call NetCDF_read_var(grp_ncid, "p_surf", .True., input_pres_surf)
  call NetCDF_read_var(grp_ncid, "T_surf", .True., input_T_surf)
  call NetCDF_read_var(grp_ncid, "sh_flux_sfc", .False., input_sh_flux_sfc)
  call NetCDF_read_var(grp_ncid, "lh_flux_sfc", .False., input_lh_flux_sfc)
  
  call NetCDF_read_var(grp_ncid, "w_ls", .True., input_w_ls)
  call NetCDF_read_var(grp_ncid, "omega", .True., input_omega)
  call NetCDF_read_var(grp_ncid, "u_g", .True., input_u_g)
  call NetCDF_read_var(grp_ncid, "v_g", .True., input_v_g)
  call NetCDF_read_var(grp_ncid, "u_nudge", .True., input_u_nudge)
  call NetCDF_read_var(grp_ncid, "v_nudge", .True., input_v_nudge)
  call NetCDF_read_var(grp_ncid, "T_nudge", .True., input_T_nudge)
  call NetCDF_read_var(grp_ncid, "thil_nudge", .True., input_thil_nudge)
  call NetCDF_read_var(grp_ncid, "qt_nudge", .True., input_qt_nudge)
  call NetCDF_read_var(grp_ncid, "dT_dt_rad", .True., input_dT_dt_rad)
  call NetCDF_read_var(grp_ncid, "h_advec_thetail", .True., input_h_advec_thetail)
  call NetCDF_read_var(grp_ncid, "h_advec_qt", .True., input_h_advec_qt)
  call NetCDF_read_var(grp_ncid, "v_advec_thetail", .True., input_v_advec_thetail)
  call NetCDF_read_var(grp_ncid, "v_advec_qt", .True., input_v_advec_qt)

  call check(NF90_CLOSE(NCID=ncid))

  call scm_input%create(input_ntimes, input_nlev, input_nsoil, input_nsnow, input_nice)
    
  ! GJF already done in scm_input%create routine
  !scm_input%input_nlev = input_nlev
  !scm_input%input_ntimes = input_ntimes

  scm_input%input_pres = input_pres
  scm_input%input_time = input_time
  scm_input%input_temp = input_temp
  scm_input%input_thetail = input_thetail
  scm_input%input_qt = input_qt
  scm_input%input_ql = input_ql
  scm_input%input_qi = input_qi
  scm_input%input_u = input_u
  scm_input%input_v = input_v
  scm_input%input_tke = input_tke
  scm_input%input_ozone = input_ozone
  scm_input%input_lat = input_lat
  scm_input%input_lon = input_lon
  scm_input%input_pres_surf = input_pres_surf
  scm_input%input_T_surf = input_T_surf
  scm_input%input_sh_flux_sfc = input_sh_flux_sfc
  scm_input%input_lh_flux_sfc = input_lh_flux_sfc
  scm_input%input_w_ls = input_w_ls
  scm_input%input_omega = input_omega
  scm_input%input_u_g = input_u_g
  scm_input%input_v_g = input_v_g
  scm_input%input_dT_dt_rad = input_dT_dt_rad
  scm_input%input_h_advec_thetail = input_h_advec_thetail
  scm_input%input_h_advec_qt = input_h_advec_qt
  scm_input%input_v_advec_thetail = input_v_advec_thetail
  scm_input%input_v_advec_qt = input_v_advec_qt
  scm_input%input_u_nudge = input_u_nudge
  scm_input%input_v_nudge = input_v_nudge
  scm_input%input_T_nudge = input_T_nudge
  scm_input%input_thil_nudge = input_thil_nudge
  scm_input%input_qt_nudge = input_qt_nudge
  
  scm_input%input_stc   = input_stc  
  scm_input%input_smc   = input_smc  
  scm_input%input_slc   = input_slc  
  
  scm_input%input_snicexy    = input_snicexy
  scm_input%input_snliqxy    = input_snliqxy
  scm_input%input_tsnoxy     = input_tsnoxy
  scm_input%input_smoiseq    = input_smoiseq
  scm_input%input_zsnsoxy    = input_zsnsoxy
  
  scm_input%input_tiice      = input_tiice
  scm_input%input_tslb       = input_tslb
  scm_input%input_smois      = input_smois
  scm_input%input_sh2o       = input_sh2o
  scm_input%input_smfr       = input_smfr
  scm_input%input_flfr       = input_flfr
  
  scm_input%input_vegsrc   = input_vegsrc
  scm_input%input_vegtyp   = REAL(input_vegtyp, kind=dp)
  scm_input%input_soiltyp  = REAL(input_soiltyp, kind=dp)
  scm_input%input_slopetype = REAL(input_slopetype, kind=dp)
  scm_input%input_tsfco    = input_tsfco
  scm_input%input_vegfrac  = input_vegfrac
  scm_input%input_shdmin   = input_shdmin
  scm_input%input_shdmax   = input_shdmax
  scm_input%input_zorlo    = input_zorlo
  scm_input%input_slmsk    = input_slmsk
  scm_input%input_canopy   = input_canopy
  scm_input%input_hice     = input_hice
  scm_input%input_fice     = input_fice
  scm_input%input_tisfc    = input_tisfc
  scm_input%input_snwdph   = input_snwdph
  scm_input%input_snoalb   = input_snoalb
  scm_input%input_sncovr   = input_sncovr
  scm_input%input_area     = input_area
  scm_input%input_tg3      = input_tg3
  scm_input%input_uustar   = input_uustar
  scm_input%input_alvsf    = input_alvsf
  scm_input%input_alnsf    = input_alnsf
  scm_input%input_alvwf    = input_alvwf
  scm_input%input_alnwf    = input_alnwf
  scm_input%input_facsf    = input_facsf
  scm_input%input_facwf    = input_facwf
  scm_input%input_weasd    = input_weasd
  scm_input%input_f10m     = input_f10m
  scm_input%input_t2m      = input_t2m
  scm_input%input_q2m      = input_q2m
  scm_input%input_ffmm     = input_ffmm
  scm_input%input_ffhh     = input_ffhh
  scm_input%input_tprcp    = input_tprcp
  scm_input%input_srflag   = input_srflag
  scm_input%input_tsfcl    = input_tsfcl
  scm_input%input_zorll    = input_zorll
  scm_input%input_zorli    = input_zorli
  scm_input%input_zorlw    = input_zorlw
  
  scm_input%input_stddev   = input_stddev
  scm_input%input_convexity= input_convexity
  scm_input%input_oa1      = input_oa1
  scm_input%input_oa2      = input_oa2
  scm_input%input_oa3      = input_oa3
  scm_input%input_oa4      = input_oa4
  scm_input%input_ol1      = input_ol1
  scm_input%input_ol2      = input_ol2
  scm_input%input_ol3      = input_ol3
  scm_input%input_ol4      = input_ol4
  scm_input%input_sigma    = input_sigma
  scm_input%input_theta    = input_theta
  scm_input%input_gamma    = input_gamma
  scm_input%input_elvmax   = input_elvmax
  scm_input%input_oro      = input_oro
  scm_input%input_oro_uf   = input_oro_uf
  scm_input%input_landfrac = input_landfrac
  scm_input%input_lakefrac = input_lakefrac
  scm_input%input_lakedepth= input_lakedepth
  
  scm_input%input_tvxy = input_tvxy
  scm_input%input_tgxy = input_tgxy
  scm_input%input_tahxy = input_tahxy
  scm_input%input_canicexy = input_canicexy
  scm_input%input_canliqxy = input_canliqxy
  scm_input%input_eahxy = input_eahxy
  scm_input%input_cmxy = input_cmxy
  scm_input%input_chxy = input_chxy
  scm_input%input_fwetxy = input_fwetxy
  scm_input%input_sneqvoxy = input_sneqvoxy
  scm_input%input_alboldxy = input_alboldxy
  scm_input%input_qsnowxy = input_qsnowxy
  scm_input%input_wslakexy = input_wslakexy
  scm_input%input_taussxy = input_taussxy
  scm_input%input_waxy = input_waxy
  scm_input%input_wtxy = input_wtxy
  scm_input%input_zwtxy = input_zwtxy
  scm_input%input_xlaixy = input_xlaixy
  scm_input%input_xsaixy = input_xsaixy
  scm_input%input_lfmassxy = input_lfmassxy
  scm_input%input_stmassxy = input_stmassxy
  scm_input%input_rtmassxy = input_rtmassxy
  scm_input%input_woodxy = input_woodxy
  scm_input%input_stblcpxy = input_stblcpxy
  scm_input%input_fastcpxy = input_fastcpxy
  scm_input%input_smcwtdxy = input_smcwtdxy
  scm_input%input_deeprechxy = input_deeprechxy
  scm_input%input_rechxy = input_rechxy
  scm_input%input_snowxy = input_snowxy
  
  scm_input%input_tref    = input_tref
  scm_input%input_z_c     = input_z_c
  scm_input%input_c_0     = input_c_0
  scm_input%input_c_d     = input_c_d
  scm_input%input_w_0     = input_w_0
  scm_input%input_w_d     = input_w_d
  scm_input%input_xt      = input_xt
  scm_input%input_xs      = input_xs
  scm_input%input_xu      = input_xu
  scm_input%input_xv      = input_xv
  scm_input%input_xz      = input_xz
  scm_input%input_zm      = input_zm
  scm_input%input_xtts    = input_xtts
  scm_input%input_xzts    = input_xzts
  scm_input%input_d_conv  = input_d_conv
  scm_input%input_ifd     = input_ifd
  scm_input%input_dt_cool = input_dt_cool
  scm_input%input_qrain   = input_qrain
  
  scm_input%input_wetness    = input_wetness
  scm_input%input_clw_surf   = input_clw_surf
  scm_input%input_qwv_surf   = input_qwv_surf
  scm_input%input_tsnow      = input_tsnow
  scm_input%input_snowfallac = input_snowfallac
  scm_input%input_acsnow     = input_acsnow
  scm_input%input_lai        = input_lai
  
!> @}
end subroutine get_case_init

!> Subroutine to get reference profile to use above the case data (temporarily hard-coded profile)
subroutine get_reference_profile(scm_state, scm_reference)
  use gmtb_scm_type_defs, only : scm_state_type, scm_reference_type
  use NetCDF_read, only: check
  
  type(scm_state_type), target, intent(in) :: scm_state
  type(scm_reference_type), target, intent(inout) :: scm_reference

  integer  :: nlev !< number of pressure levels in the reference profile
  real(kind=dp), allocatable :: pres(:)  !< reference profile pressure (Pa)
  real(kind=dp), allocatable :: T(:) !< reference profile temperature (K)
  real(kind=dp), allocatable :: qv(:) !< reference profile specific humidity (kg kg^-1)
  real(kind=dp), allocatable :: ozone(:) !< reference profile ozone concentration (kg kg^-1)

  integer :: i, ioerror
  character(len=120)                 :: line
  real :: dummy

  integer                           :: ncid, varID, allocate_status
  CHARACTER(LEN=nf90_max_name)      :: tmpName

  select case (scm_state%reference_profile_choice)
    case (1)
      open(unit=1, file=trim(adjustl(scm_state%case_data_dir))//'/'//'McCProfiles.dat', status='old', action='read', iostat=ioerror)
      if(ioerror /= 0) then
        write(*,*) 'There was an error opening the file McCprofiles.dat in the processed_case_input directory. &
          Error code = ',ioerror
        stop
      endif

      ! find number of records
      read(1, '(a)', iostat=ioerror) line !first line is header
      nlev = 0
      do
        read(1, '(a)', iostat=ioerror) line
        if (ioerror /= 0) exit
        nlev = nlev + 1
      end do

      allocate(pres(nlev), T(nlev), qv(nlev), ozone(nlev))

      rewind(1)
      read(1, '(a)', iostat=ioerror) line !first line is header
      do i=1, nlev
        read(1,'(5ES16.4)', iostat=ioerror) dummy, pres(i), T(i), qv(i), ozone(i)
      END DO
      close(1)
    case (2)
      call check(NF90_OPEN(trim(adjustl(scm_state%case_data_dir))//'/'//'mid_lat_summer_std.nc',nf90_nowrite,ncid))

      call check(NF90_INQ_DIMID(ncid,"height",varID))
      call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, nlev))

      !> - Allocate the dimension variables.
      allocate(pres(nlev), T(nlev), qv(nlev), ozone(nlev), stat=allocate_status)

      call check(NF90_INQ_VARID(ncid,"pressure",varID))
      call check(NF90_GET_VAR(ncid,varID,pres))
      call check(NF90_INQ_VARID(ncid,"temperature",varID))
      call check(NF90_GET_VAR(ncid,varID,T))
      call check(NF90_INQ_VARID(ncid,"q_v",varID))
      call check(NF90_GET_VAR(ncid,varID,qv))
      call check(NF90_INQ_VARID(ncid,"o3",varID))
      call check(NF90_GET_VAR(ncid,varID,ozone))

      call check(NF90_CLOSE(NCID=ncid))

  end select

  call scm_reference%create(nlev)

  scm_reference%ref_nlev = nlev
  scm_reference%ref_pres = pres
  scm_reference%ref_T = T
  scm_reference%ref_qv = qv
  scm_reference%ref_ozone = ozone


end subroutine get_reference_profile

!> Subroutine to get reference profile to use above the case data (temporarily hard-coded profile)
subroutine get_reference_profile_old(nlev, pres, T, qv, ozone)
  integer, intent(out)  :: nlev !< number of pressure levels in the reference profile
  real(kind=dp), allocatable, intent(out) :: pres(:)  !< reference profile pressure (Pa)
  real(kind=dp), allocatable, intent(out) :: T(:) !< reference profile temperature (K)
  real(kind=dp), allocatable, intent(out) :: qv(:) !< reference profile specific humidity (kg kg^-1)
  real(kind=dp), allocatable, intent(out) :: ozone(:) !< reference profile ozone concentration (kg kg^-1)

  !> \todo write a more sophisticated reference profile subroutine (can choose between reference profiles)

  !> - For the prototype, the 'McClatchey' sounding used in Jennifer Fletcher's code is hardcoded.
  nlev = 20

  allocate(pres(nlev), T(nlev), qv(nlev), ozone(nlev))

  pres = (/ 1030.0, 902.0, 802.0, 710.0, 628.0, 554.0, 487.0, 426.0, 372.0, 281.0, 209.0, 130.0, 59.5, 27.7, 13.2, 6.52, 3.33, &
    0.951, 0.0671, 0.000300 /)
  pres = pres*100.0

  T = (/ 294., 290., 285., 279., 273., 267., 261., 255., 248., 235., 222., 216., 218., 224., 234., 245., 258., 276., 218., 210. /)

  qv = (/ 11.75, 8.611, 6.047, 3.877, 2.363, 1.387, 0.9388, 0.6364, 0.4019, 0.1546, 0.01976, 0.004002, 0.003999, 0.004011, &
    0.004002, 0.004004, 0.003994, 0.003995, 0.003996, 0.004000 /)
  qv = qv*1.0E-3

  ozone = (/ 6., 6., 6., 6.2, 6.4, 6.6, 6.9, 7.5, 7.9, 9., 12., 19., 34., 30., 20., 9.2, 4.1, 0.43, 0.0086, 0.0000043 /)
  ozone = ozone*1.0E-5

end subroutine get_reference_profile_old

subroutine get_tracers(tracer_names)
  character(len=character_length), allocatable, intent(inout), dimension(:) :: tracer_names

  character(len=*), parameter :: file_name = 'tracers.txt'

  character(len=100) :: name!, std_name, units
  integer            :: i, fu, rc, n_lines

  open (action='read', file=FILE_NAME, iostat=rc, newunit=fu)
    if (rc == 0) then
        n_lines = 0
        do
            read (fu, *, iostat=rc) name!, std_name, units
            if (rc /= 0) exit
            n_lines = n_lines + 1
        end do
        allocate(tracer_names(n_lines))
        rewind(fu)
        do i=1,n_lines
            read (fu, *, iostat=rc) name!, std_name, units
            if (rc /= 0) exit
            tracer_names(i) = trim(name)
        end do
    else
        write(*,'(a,i0)') 'There was an error opening the file ' // FILE_NAME // &
                          '; error code = ', rc
        stop
    end if

    close (fu)
end subroutine get_tracers

!> @}
!> @}
end module gmtb_scm_input
