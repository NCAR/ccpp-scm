!> \file scm_input.f90
!!  Contains input-related subroutines -- reading in model configuration from file or the command line and reading in the case
!!  initial conditions and forcing; also contains reference profile input (temporarily hard-coded).

module scm_input

use scm_kinds, only : sp, dp, qp
use netcdf
use scm_type_defs, only: character_length

implicit none

integer :: missing_snow_layers = 3
integer :: missing_soil_layers = 4
integer :: missing_ice_layers = 2

contains

!> \ingroup SCM
!! @{
!! \defgroup input scm_input
!! @{
!! Contains input-related subroutines -- reading in model configuration from file or the command line and reading in the case
!! initial conditions and forcing; also contains reference profile input (temporarily hard-coded).

!> Subroutine to get basic model configuration data from a namelist file (whose name is specified as the first argument on the command line) and from
!! data entered on the command line with the format: "var1='string' var2=d.d var3=i". Namelist variables listed on the command line
!! override those that are specified in the external namelist file. The case configuration namelist variables are also written out to
!! a namelist file placed in the output directory. Note: This routine uses GET_COMMAND which is an intrinsic routine in the Fortran 2003 standard. This
!! requires that the compiler supports this standard.
subroutine get_config_nml(scm_state)
  use scm_type_defs, only : scm_state_type

  type(scm_state_type), target, intent(inout) :: scm_state

  character(len=character_length)    :: experiment_name !< name of the experiment configuration file (usually case name)
  character(len=character_length)    :: model_name !< name of the host model (currently only GFS supported)
  character(len=character_length)    :: case_name !< name of case initialization and forcing dataset
  real(kind=dp)        :: dt !< time step in seconds
  real(kind=dp)        :: runtime !< total runtime in seconds
  integer              :: n_itt_out !< multiple of timestep for writing output
  integer              :: n_itt_diag !< multiple of timestep for resetting diagnostics (overwrites fhzero from physics namelist if present)
  integer              :: n_levels !< number of model levels (currently only 64 supported)
  integer              :: n_soil   !< number of model soil levels (currently only 4 supported)
  integer              :: n_snow   !< number of model snow levels (currently only 3 supported)
  integer              :: n_columns !< number of columns to use
  integer              :: n_time_levels
  integer              :: time_scheme !< 1 => forward Euler, 2 => filtered leapfrog
  character(len=character_length)    :: output_dir !< name of the output directory
  character(len=character_length)    :: output_file !< name of the output file (without the file extension)
  character(len=character_length)    :: case_data_dir !< path to the directory containing case initialization and forcing data
  character(len=character_length)    :: vert_coord_data_dir !< path to the directory containing vertical coordinate data
  character(len=character_length)    :: reference_profile_dir !< path to the directory containing the reference profile
  integer              :: thermo_forcing_type !< 1: "revealed forcing", 2: "horizontal advective forcing", 3: "relaxation forcing"
  integer              :: mom_forcing_type !< 1: "revealed forcing", 2: "horizontal advective forcing", 3: "relaxation forcing"
  integer              :: C_RES            !< reference "C" resoltiion of FV3 grid (needed for GWD and mountain blocking)
  integer              :: spinup_timesteps
  real(kind=dp)        :: relax_time !< relaxation time scale (s)
  logical              :: sfc_flux_spec !< flag for using specified surface fluxes instead of calling a surface scheme
  real(kind=dp)        :: sfc_roughness_length_cm !< surface roughness length used for calculating surface layer parameters from specified fluxes
  integer              :: sfc_type !< 0: sea surface, 1: land surface, 2: sea-ice surface
  logical              :: model_ics !<  true means have land info too
  logical              :: lsm_ics !< true when LSM initial conditions are included (but not all ICs from another model)
  logical              :: do_spinup
  integer              :: reference_profile_choice !< 1: McClatchey profile, 2: mid-latitude summer standard atmosphere
  integer              :: year, month, day, hour, min
  real(kind=dp)        :: column_area
  integer              :: input_type !< 0 => original DTC format, 1 => DEPHY-SCM format

  character(len=character_length)    :: physics_suite !< name of the physics suite name (currently only GFS_operational supported)
  character(len=character_length)    :: physics_nml
  
  character(len=character_length), allocatable, dimension(:) :: tracer_names
  integer,                         allocatable, dimension(:) :: tracer_types

  integer                          :: ioerror

  CHARACTER(LEN=*), parameter :: experiment_namelist = 'input_experiment.nml'

  NAMELIST /case_config/ model_name, n_columns, case_name, dt, time_scheme, runtime, n_itt_out, n_itt_diag, &
    n_levels, output_dir, output_file, case_data_dir, vert_coord_data_dir, thermo_forcing_type, model_ics, &
    lsm_ics, do_spinup, C_RES, spinup_timesteps, mom_forcing_type, relax_time, sfc_type, sfc_flux_spec, &
    sfc_roughness_length_cm, reference_profile_choice, reference_profile_dir, year, month, day, hour, min, &
    column_area, input_type
    
  NAMELIST /physics_config/ physics_suite, physics_nml

  !>  \section get_config_alg Algorithm
  !!  @{

  !> Define default values for experiment configuration (to be overridden by external namelist file or command line arguments)
  model_name = 'GFS'
  n_columns = 1
  case_name = 'twpice'
  dt = 600.0
  time_scheme = 2
  runtime = 2138400.0
  n_itt_out = 1
  n_itt_diag = -999
  n_levels = 64
  n_soil   = 4
  n_snow   = 3
  output_dir = 'output'
  output_file = 'output'
  case_data_dir = '../data/processed_case_input'
  vert_coord_data_dir = '../data/vert_coord_data'
  thermo_forcing_type = 2
  mom_forcing_type = 3
  C_RES = 384
  spinup_timesteps = 0
  relax_time = 7200.0
  sfc_flux_spec = .false.
  sfc_roughness_length_cm = 1.0
  sfc_type = 0
  model_ics = .false.
  lsm_ics = .false.
  do_spinup = .false.
  reference_profile_choice = 1
  reference_profile_dir = case_data_dir
  year = 2006
  month = 1
  day = 19
  hour = 3
  min = 0
  input_type = 0
  
  open(unit=10, file=experiment_namelist, status='old', action='read', iostat=ioerror)
  if(ioerror /= 0) then
    write(*,'(a,i0)') 'There was an error opening the file ' // experiment_namelist // &
                      '; error code = ', ioerror
    STOP
  else
    read(10, NML=case_config, iostat=ioerror)
  end if

  if(ioerror /= 0) then
    write(*,'(a,i0)') 'There was an error reading the namelist case_config in the file '&
                      // experiment_namelist // '; error code = ',ioerror
    STOP
  end if

  !The current implementation of GFS physics does not support more than one column, since radiation sub schemes use
  !internal module variables. This means that one cannot specify different ways to treat O3, CO2 etc., and also that
  !the code crashes in GFS_initialize_scm_run and later in radiation_gases.f, because it tries to allocate module
  !variables that are already allocated. For now, throw an error and abort.
  if (n_columns>1) then
    write(*,'(a)') 'The current implementation does not allow to run more than one column at a time.'
    STOP
  end if
  
  !read in the physics suite and namelist
  read(10, NML=physics_config, iostat=ioerror)
  close(10)

  select case(time_scheme)
    case(1)
      n_time_levels = 1
    case(2)
      n_time_levels = 2
    case default
      n_time_levels = 2
  end select
  
  call get_tracers(tracer_names, tracer_types)
  
  call scm_state%create(n_columns, n_levels, n_soil, n_snow, n_time_levels, tracer_names, tracer_types)

  scm_state%experiment_name = experiment_name
  scm_state%model_name = model_name
  scm_state%output_dir = output_dir
  scm_state%case_data_dir = case_data_dir
  scm_state%vert_coord_data_dir = vert_coord_data_dir
  scm_state%reference_profile_dir = reference_profile_dir
  scm_state%output_file = output_file
  scm_state%case_name = case_name
  scm_state%physics_suite_name = physics_suite
  scm_state%physics_nml = physics_nml
  scm_state%area(:) = column_area

  scm_state%n_cols = n_columns
  scm_state%n_levels = n_levels
  scm_state%n_time_levels = n_time_levels
  scm_state%dt = dt
  scm_state%n_itt_out = n_itt_out
  scm_state%n_itt_diag = n_itt_diag
  scm_state%runtime = runtime
  scm_state%time_scheme = time_scheme
  scm_state%init_year = year
  scm_state%init_month = month
  scm_state%init_day = day
  scm_state%init_hour = hour
  scm_state%init_min = min

  scm_state%output_period = n_itt_out*dt
  scm_state%thermo_forcing_type = thermo_forcing_type
  scm_state%mom_forcing_type = mom_forcing_type
  scm_state%C_RES            = C_RES
  scm_state%spinup_timesteps = spinup_timesteps
  scm_state%sfc_flux_spec = sfc_flux_spec
  scm_state%sfc_roughness_length_cm(:) = sfc_roughness_length_cm
  scm_state%sfc_type = REAL(sfc_type, kind=dp)
  scm_state%model_ics = model_ics
  scm_state%lsm_ics = lsm_ics
  scm_state%do_spinup = do_spinup
  scm_state%reference_profile_choice = reference_profile_choice
  scm_state%relax_time = relax_time
  scm_state%input_type = input_type
  
  deallocate(tracer_names)
!> @}
end subroutine get_config_nml


!> Subroutine to read the netCDF file containing case initialization and forcing. The forcing files (netCDF4) should be located in the
!! "processed_case_input" directory.
subroutine get_case_init(scm_state, scm_input)
  use scm_type_defs, only : scm_state_type, scm_input_type
  use NetCDF_read, only: NetCDF_read_var, check, missing_value
  type(scm_state_type), intent(in) :: scm_state
  type(scm_input_type), target, intent(inout) :: scm_input
  
  integer               :: input_nlev !< number of levels in the input file
  integer               :: input_nsoil !< number of soil levels in the input file
  integer               :: input_ntimes !< number of times represented in the input file
  integer               :: input_nsnow !< number of snow levels in the input file
  integer               :: input_nice !< number of sea ice levels in the input file
  integer               :: input_nsoil_plus_nsnow !< number of combined snow and soil levels in the input file

  ! dimension variables
  real(kind=dp), allocatable  :: input_pres(:) !< input file pressure levels (Pa)
  real(kind=dp), allocatable  :: input_time(:) !< input file times (seconds since the beginning of the case)

  !initial profile variables
  real(kind=dp), allocatable  :: input_thetail(:) !< ice-liquid water potential temperature profile (K)
  real(kind=dp), allocatable  :: input_temp(:) !< temperature profile (K)
  real(kind=dp), allocatable  :: input_qt(:) !< total water specific humidity profile (kg kg^-1)
  real(kind=dp), allocatable  :: input_ql(:) !< liquid water specific humidity profile (kg kg^-1)
  real(kind=dp), allocatable  :: input_qi(:) !< ice water specific humidity profile (kg kg^-1)
  real(kind=dp), allocatable  :: input_u(:) !< east-west horizontal wind profile (m s^-1)
  real(kind=dp), allocatable  :: input_v(:) !< north-south horizontal wind profile (m s^-1)
  real(kind=dp), allocatable  :: input_tke(:) !< TKE profile (m^2 s^-2)
  real(kind=dp), allocatable  :: input_ozone(:) !< ozone profile (kg kg^-1)
! additional land info
  real(kind=dp), allocatable  :: input_stc(:) !< soil temperature (K)
  real(kind=dp), allocatable  :: input_smc(:) !< total soil moisture content (fraction)  
  real(kind=dp), allocatable  :: input_slc(:) !< liquid soil moisture content (fraction)
  !real(kind=dp), allocatable  :: input_pres_i(:) !< interface pressures
  !real(kind=dp), allocatable  :: input_pres_l(:) !< layer pressures
  real(kind=dp), allocatable  :: input_snicexy(:) !< snow layer ice (mm)
  real(kind=dp), allocatable  :: input_snliqxy(:) !< snow layer liquid (mm)
  real(kind=dp), allocatable  :: input_tsnoxy(:) !< snow temperature (K)
  real(kind=dp), allocatable  :: input_smoiseq(:) !< equilibrium soil water content (m3 m-3)
  real(kind=dp), allocatable  :: input_zsnsoxy(:) !< layer bottom depth from snow surface (m)
  real(kind=dp), allocatable  :: input_tiice(:)   !< sea ice internal temperature (K)
  real(kind=dp), allocatable  :: input_tslb(:)    !< soil temperature for RUC LSM (K)
  real(kind=dp), allocatable  :: input_smois(:)   !< volume fraction of soil moisture for RUC LSM (frac)
  real(kind=dp), allocatable  :: input_sh2o(:)    !< volume fraction of unfrozen soil moisture for RUC LSM (frac)
  real(kind=dp), allocatable  :: input_smfr(:)    !< volume fraction of frozen soil moisture for RUC LSM (frac)
  real(kind=dp), allocatable  :: input_flfr(:)    !< flag for frozen soil physics
  
  integer                     :: input_vegsrc !< vegetation source
  integer                     :: input_vegtyp !< vegetation type
  integer                     :: input_soiltyp!< soil type
  integer                     :: input_slopetype !< slope type
  real(kind=dp)               :: input_lat !< column latitude (deg)
  real(kind=dp)               :: input_lon !< column longitude (deg)
  real(kind=dp)               :: input_tsfco !< input sea surface temperature OR surface skin temperature over land OR surface skin temperature over ice (depending on slmsk) (K)
  real(kind=dp)               :: input_vegfrac  !< vegetation fraction
  real(kind=dp)               :: input_shdmin  !< minimun vegetation fraction
  real(kind=dp)               :: input_shdmax  !< maximun vegetation fraction
  real(kind=dp)               :: input_zorlw    !< surfce roughness length over water [cm]
  real(kind=dp)               :: input_slmsk   !< sea land ice mask [0,1,2]
  real(kind=dp)               :: input_canopy  !< amount of water stored in canopy (kg m-2)
  real(kind=dp)               :: input_hice    !< sea ice thickness (m)
  real(kind=dp)               :: input_fice    !< ice fraction (frac)
  real(kind=dp)               :: input_tisfc   !< ice surface temperature (K)
  real(kind=dp)               :: input_snwdph  !< water equivalent snow depth (mm)
  real(kind=dp)               :: input_snoalb  !< maximum snow albedo (frac)
  real(kind=dp)               :: input_sncovr  !< snow area fraction (frac)
  real(kind=dp)               :: input_area    !< surface area [m^2]
  real(kind=dp)               :: input_tg3     !< deep soil temperature (K)
  real(kind=dp)               :: input_uustar  !< surface friction velocity (m s-1)
  real(kind=dp)               :: input_alvsf !< 60 degree vis albedo with strong cosz dependency
  real(kind=dp)               :: input_alnsf !< 60 degree nir albedo with strong cosz dependency
  real(kind=dp)               :: input_alvwf !< 60 degree vis albedo with weak cosz dependency
  real(kind=dp)               :: input_alnwf !< 60 degree nir albedo with weak cosz dependency
  real(kind=dp)               :: input_facsf !< fractional coverage with strong cosz dependency
  real(kind=dp)               :: input_facwf !< fractional coverage with weak cosz dependency
  real(kind=dp)               :: input_weasd !< water equivalent accumulated snow depth (mm)
  real(kind=dp)               :: input_f10m  !< ratio of sigma level 1 wind and 10m wind
  real(kind=dp)               :: input_t2m    !< 2-meter absolute temperature (K)
  real(kind=dp)               :: input_q2m    !< 2-meter specific humidity (kg kg-1)
  real(kind=dp)               :: input_ffmm    !< Monin-Obukhov similarity function for momentum
  real(kind=dp)               :: input_ffhh    !< Monin-Obukhov similarity function for heat
  real(kind=dp)               :: input_tprcp   !< instantaneous total precipitation amount (m)
  real(kind=dp)               :: input_srflag  !< snow/rain flag for precipitation
  real(kind=dp)               :: input_tsfcl   !< surface skin temperature over land (K)
  real(kind=dp)               :: input_zorll   !< surface roughness length over land (cm)
  real(kind=dp)               :: input_zorli   !< surface roughness length over ice (cm)
  real(kind=dp)               :: input_zorlwav   !< surface roughness length from wave model (cm)
  
  real(kind=dp)               :: input_stddev !< standard deviation of subgrid orography (m)
  real(kind=dp)               :: input_convexity !< convexity of subgrid orography 
  real(kind=dp)               :: input_ol1 !< fraction of grid box with subgrid orography higher than critical height 1
  real(kind=dp)               :: input_ol2 !< fraction of grid box with subgrid orography higher than critical height 2
  real(kind=dp)               :: input_ol3 !< fraction of grid box with subgrid orography higher than critical height 3
  real(kind=dp)               :: input_ol4 !< fraction of grid box with subgrid orography higher than critical height 4
  real(kind=dp)               :: input_oa1 !< assymetry of subgrid orography 1
  real(kind=dp)               :: input_oa2 !< assymetry of subgrid orography 2
  real(kind=dp)               :: input_oa3 !< assymetry of subgrid orography 3
  real(kind=dp)               :: input_oa4 !< assymetry of subgrid orography 4
  real(kind=dp)               :: input_sigma !< slope of subgrid orography
  real(kind=dp)               :: input_theta !< angle with respect to east of maximum subgrid orographic variations (deg)
  real(kind=dp)               :: input_gamma !< anisotropy of subgrid orography
  real(kind=dp)               :: input_elvmax!< maximum of subgrid orography (m)
  real(kind=dp)               :: input_oro !< orography (m)
  real(kind=dp)               :: input_oro_uf !< unfiltered orography (m)
  real(kind=dp)               :: input_landfrac !< fraction of horizontal grid area occupied by land
  real(kind=dp)               :: input_lakefrac !< fraction of horizontal grid area occupied by lake
  real(kind=dp)               :: input_lakedepth !< lake depth (m)
  
  real(kind=dp)               :: input_tvxy !< vegetation temperature (K)
  real(kind=dp)               :: input_tgxy !< ground temperature for Noahmp (K)
  real(kind=dp)               :: input_tahxy !< canopy air temperature (K)
  real(kind=dp)               :: input_canicexy !< canopy intercepted ice mass (mm)
  real(kind=dp)               :: input_canliqxy !< canopy intercepted liquid water (mm)
  real(kind=dp)               :: input_eahxy !< canopy air vapor pressure (Pa)
  real(kind=dp)               :: input_cmxy !< surface drag coefficient for momentum for noahmp
  real(kind=dp)               :: input_chxy !< surface exchange coeff heat & moisture for noahmp
  real(kind=dp)               :: input_fwetxy !< area fraction of canopy that is wetted/snowed
  real(kind=dp)               :: input_sneqvoxy !< snow mass at previous time step (mm)
  real(kind=dp)               :: input_alboldxy !< snow albedo at previous time step (frac)
  real(kind=dp)               :: input_qsnowxy !< snow precipitation rate at surface (mm s-1)
  real(kind=dp)               :: input_wslakexy !< lake water storage (mm)
  real(kind=dp)               :: input_taussxy !< non-dimensional snow age
  real(kind=dp)               :: input_waxy !< water storage in aquifer (mm)
  real(kind=dp)               :: input_wtxy !< water storage in aquifer and saturated soil (mm)
  real(kind=dp)               :: input_zwtxy !< water table depth (m)
  real(kind=dp)               :: input_xlaixy !< leaf area index
  real(kind=dp)               :: input_xsaixy !< stem area index
  real(kind=dp)               :: input_lfmassxy !< leaf mass (g m-2)
  real(kind=dp)               :: input_stmassxy !< stem mass (g m-2)
  real(kind=dp)               :: input_rtmassxy !< fine root mass (g m-2)
  real(kind=dp)               :: input_woodxy !< wood mass including woody roots (g m-2)
  real(kind=dp)               :: input_stblcpxy !< stable carbon in deep soil (g m-2)
  real(kind=dp)               :: input_fastcpxy !< short-lived carbon in shallow soil (g m-2)
  real(kind=dp)               :: input_smcwtdxy !< soil water content between the bottom of the soil and the water table (m3 m-3)
  real(kind=dp)               :: input_deeprechxy !< recharge to or from the water table when deep (m)
  real(kind=dp)               :: input_rechxy !< recharge to or from the water table when shallow (m)
  real(kind=dp)               :: input_snowxy !< number of snow layers
  real(kind=dp)               :: input_albdvis !<
  real(kind=dp)               :: input_albdnir !<
  real(kind=dp)               :: input_albivis !<
  real(kind=dp)               :: input_albinir !<
  real(kind=dp)               :: input_emiss   !<
  
  real(kind=dp)               :: input_tref !< sea surface reference temperature for NSST (K)
  real(kind=dp)               :: input_z_c !< sub-layer cooling thickness for NSST (m)
  real(kind=dp)               :: input_c_0 !< coefficient 1 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_c_d !< coefficient 2 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_w_0 !< coefficient 3 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_w_d !< coefficient 4 to calculate d(Tz)/d(Ts) for NSST
  real(kind=dp)               :: input_xt !< heat content in diurnal thermocline layer for NSST (K m)
  real(kind=dp)               :: input_xs !< salinity content in diurnal thermocline layer for NSST (ppt m)
  real(kind=dp)               :: input_xu !< u-current in diurnal thermocline layer for NSST (m2 s-1)
  real(kind=dp)               :: input_xv !< v-current in diurnal thermocline layer for NSST (m2 s-1)
  real(kind=dp)               :: input_xz !< thickness of diurnal thermocline layer for NSST (m)
  real(kind=dp)               :: input_zm !< thickness of ocean mixed layer for NSST (m)
  real(kind=dp)               :: input_xtts !< sensitivity of diurnal thermocline layer heat content to surface temperature [d(xt)/d(ts)] for NSST (m)
  real(kind=dp)               :: input_xzts !< sensitivity of diurnal thermocline layer thickness to surface temperature [d(xz)/d(ts)] for NSST (m K-1)
  real(kind=dp)               :: input_d_conv !< thickness of free convection layer for NSST (m)
  real(kind=dp)               :: input_ifd !< index to start DTM run for NSST
  real(kind=dp)               :: input_dt_cool !< sub-layer cooling amount for NSST (K)
  real(kind=dp)               :: input_qrain !< sensible heat due to rainfall for NSST (W)
  
  real(kind=dp)               :: input_wetness !< normalized soil wetness for RUC LSM
  real(kind=dp)               :: input_clw_surf_land !< cloud condensed water mixing ratio at surface over land for RUC LSM (kg kg-1)
  real(kind=dp)               :: input_clw_surf_ice !< cloud condensed water mixing ratio at surface over ice for RUC LSM (kg kg-1)
  real(kind=dp)               :: input_qwv_surf_land !< water vapor mixing ratio at surface over land for RUC LSM (kg kg-1)
  real(kind=dp)               :: input_qwv_surf_ice !< water vapor mixing ratio at surface over ice for RUC LSM (kg kg-1)
  real(kind=dp)               :: input_tsnow_land !< snow temperature at the bottom of the first snow layer over land for RUC LSM (K)
  real(kind=dp)               :: input_tsnow_ice !< snow temperature at the bottom of the first snow layer over ice for RUC LSM (K)
  real(kind=dp)               :: input_snowfallac_land !< run-total snow accumulation on the ground over land for RUC LSM (kg m-2)
  real(kind=dp)               :: input_snowfallac_ice !< run-total snow accumulation on the ground over ice for RUC LSM (kg m-2)
  real(kind=dp)               :: input_sncovr_ice !<
  real(kind=dp)               :: input_lai !< leaf area index for RUC LSM
  
  !surface time-series variables
  real(kind=dp), allocatable  :: input_pres_surf(:) !< time-series of surface pressure (Pa)
  real(kind=dp), allocatable  :: input_T_surf(:) !< time-series of surface temperature (K)
  real(kind=dp), allocatable  :: input_sh_flux_sfc(:) !< time-series of surface sensible heat flux (K m s^-1)
  real(kind=dp), allocatable  :: input_lh_flux_sfc(:) !< time-series of surface latent heat flux (kg kg^-1 m s^-1)

  !2D (time, pressure) variables
  real(kind=dp), allocatable  :: input_w_ls(:,:) !< 2D vertical velocity (m s^-1)
  real(kind=dp), allocatable  :: input_omega(:,:) !< 2D pressure vertical velocity (Pa s^-1)
  real(kind=dp), allocatable  :: input_u_g(:,:) !< 2D geostrophic east-west wind (m s^-1)
  real(kind=dp), allocatable  :: input_v_g(:,:) !< 2D geostrophic north-south wind (m s^-1)
  real(kind=dp), allocatable  :: input_u_nudge(:,:) !< 2D nudging east-west wind (m s^-1)
  real(kind=dp), allocatable  :: input_v_nudge(:,:) !< 2D nudging north-south wind (m s^-1)
  real(kind=dp), allocatable  :: input_T_nudge(:,:) !< 2D nudging abs. temperature (K)
  real(kind=dp), allocatable  :: input_thil_nudge(:,:) !< 2D nudging liq. pot. temperature (K)
  real(kind=dp), allocatable  :: input_qt_nudge(:,:) !< 2D nudging specific humidity (kg kg^-1)
  real(kind=dp), allocatable  :: input_dT_dt_rad(:,:) !< 2D radiative heating rate (K s^-1)
  real(kind=dp), allocatable  :: input_h_advec_thetail(:,:) !< 2D theta_il tendency due to large-scale horizontal advection (K s^-1)
  real(kind=dp), allocatable  :: input_h_advec_qt(:,:) !< 2D q_t tendency due to large-scale horizontal advection (kg kg^-1 s^-1)
  real(kind=dp), allocatable  :: input_v_advec_thetail(:,:) !< 2D theta_il tendency due to large-scale vertical advection (K s^-1)
  real(kind=dp), allocatable  :: input_v_advec_qt(:,:) !< 2D q_t tendency due to large-scale horizontal vertical (kg kg^-1 s^-1)

  CHARACTER(LEN=nf90_max_name)      :: tmpName
  integer                           :: ncid, varID, grp_ncid, allocate_status,ierr
  real(kind=dp)                     :: nc_missing_value

  !>  \section get_case_init_alg Algorithm
  !!  @{

  !> - Open the case input file found in the processed_case_input dir corresponding to the experiment name.
  call check(NF90_OPEN(trim(adjustl(scm_state%case_data_dir))//'/'//trim(adjustl(scm_state%case_name))//'.nc',nf90_nowrite,ncid))
  
  !> - Read in missing value from file (replace module variable if present)
  ierr = NF90_GET_ATT(ncid, NF90_GLOBAL, 'missing_value', nc_missing_value)
  if(ierr == NF90_NOERR) then
    missing_value = nc_missing_value
  end if
  
  !> - Get the dimensions (global group).
  
  !required dimensions
  call check(NF90_INQ_DIMID(ncid,"levels",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nlev))
  call check(NF90_INQ_DIMID(ncid,"time",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_ntimes))
  
  !possible dimensions (if using model ICs)
  ierr = NF90_INQ_DIMID(ncid,"nsoil",varID)
  if(ierr /= NF90_NOERR) then
    input_nsoil = missing_soil_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nsoil))
  end if
  ierr = NF90_INQ_DIMID(ncid,"nsnow",varID)
  if(ierr /= NF90_NOERR) then
    input_nsnow = missing_snow_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nsnow))
  end if
  ierr = NF90_INQ_DIMID(ncid,"nice",varID)
  if(ierr /= NF90_NOERR) then
    input_nice = missing_ice_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_nice))
  end if  
  
  !> - Allocate the dimension variables.
  allocate(input_pres(input_nlev),input_time(input_ntimes), stat=allocate_status)

  !> - Read in the dimension variables (required).
  call NetCDF_read_var(ncid, "levels", .True., input_pres)
  call NetCDF_read_var(ncid, "time", .True., input_time)

  !> - Read in the initial conditions.

  !>  - Find group ncid for initial group.
  call check(NF90_INQ_GRP_NCID(ncid,"initial",grp_ncid))

  !>  - Allocate the initial profiles (required). One of thetail or temp is required.
  allocate(input_thetail(input_nlev), input_temp(input_nlev), input_qt(input_nlev), input_ql(input_nlev), input_qi(input_nlev), &
    input_u(input_nlev), input_v(input_nlev), input_tke(input_nlev), input_ozone(input_nlev), stat=allocate_status)
  
  !>  - Read in the initial profiles. The variable names in all input files are expected to be identical.
  
  !Either thetail or T must be present
  call NetCDF_read_var(grp_ncid, "thetail", .False., input_thetail)
  call NetCDF_read_var(grp_ncid, "temp", .False., input_temp)
  if (maxval(input_thetail) < 0 .and. maxval(input_temp) < 0) then
    write(*,*) "One of thetail or temp variables must be present in ",trim(adjustl(scm_state%case_name))//'.nc',". Stopping..."
    STOP
  end if
  call NetCDF_read_var(grp_ncid, "qt",    .True., input_qt   )
  call NetCDF_read_var(grp_ncid, "ql",    .True., input_ql   )
  call NetCDF_read_var(grp_ncid, "qi",    .True., input_qi   )
  call NetCDF_read_var(grp_ncid, "u",     .True., input_u    )
  call NetCDF_read_var(grp_ncid, "v",     .True., input_v    )
  call NetCDF_read_var(grp_ncid, "tke",   .True., input_tke  )
  call NetCDF_read_var(grp_ncid, "ozone", .True., input_ozone)
  
  !possible initial profiles
  !needed for Noah LSM and others (when running with model ICs)
  allocate(input_stc(input_nsoil), input_smc(input_nsoil), input_slc(input_nsoil), &
           stat=allocate_status)
  call NetCDF_read_var(grp_ncid, "stc", .False., input_stc)
  call NetCDF_read_var(grp_ncid, "smc", .False., input_smc)
  call NetCDF_read_var(grp_ncid, "slc", .False., input_slc)
  
  !needed for NoahMP LSM (when running with model ICs)
  allocate(input_snicexy(input_nsnow), input_snliqxy(input_nsnow), input_tsnoxy(input_nsnow), &
     input_smoiseq(input_nsoil), input_zsnsoxy(input_nsnow + input_nsoil))
  call NetCDF_read_var(grp_ncid, "snicexy", .False., input_snicexy)
  call NetCDF_read_var(grp_ncid, "snliqxy", .False., input_snliqxy)
  call NetCDF_read_var(grp_ncid, "tsnoxy",  .False., input_tsnoxy )
  call NetCDF_read_var(grp_ncid, "smoiseq", .False., input_smoiseq)
  call NetCDF_read_var(grp_ncid, "zsnsoxy", .False., input_zsnsoxy)
  
  !needed for fractional grid (when running with model ICs)
  allocate(input_tiice(input_nice))
  call NetCDF_read_var(grp_ncid, "tiice", .False., input_tiice)
  
  !needed for RUC LSM (when running with model ICs)
  allocate(input_tslb(input_nsoil), input_smois(input_nsoil), input_sh2o(input_nsoil), &
      input_smfr(input_nsoil), input_flfr(input_nsoil))
  call NetCDF_read_var(grp_ncid, "tslb",  .False., input_tslb )
  call NetCDF_read_var(grp_ncid, "smois", .False., input_smois)
  call NetCDF_read_var(grp_ncid, "sh2o",  .False., input_sh2o )
  call NetCDF_read_var(grp_ncid, "smfr",  .False., input_smfr )
  call NetCDF_read_var(grp_ncid, "flfr",  .False., input_flfr )
  
  !>  - Find group ncid for scalar group.
  call check(NF90_INQ_GRP_NCID(ncid,"scalars",grp_ncid))
  
  !required
  call NetCDF_read_var(grp_ncid, "lat", .True., input_lat)
  call NetCDF_read_var(grp_ncid, "lon", .True., input_lon)
  !time data and area in file ignored?
  call NetCDF_read_var(grp_ncid, "area", .False., input_area)
  
  !possible scalars
  !Noah LSM parameters (when running with model ICs)
  call NetCDF_read_var(grp_ncid, "vegsrc",   .False., input_vegsrc   )
  call NetCDF_read_var(grp_ncid, "vegtyp",   .False., input_vegtyp   )
  call NetCDF_read_var(grp_ncid, "soiltyp",  .False., input_soiltyp  )
  call NetCDF_read_var(grp_ncid, "slopetyp", .False., input_slopetype)
  call NetCDF_read_var(grp_ncid, "tsfco",   .False., input_tsfco)
  call NetCDF_read_var(grp_ncid, "vegfrac", .False., input_vegfrac)
  call NetCDF_read_var(grp_ncid, "shdmin",  .False., input_shdmin)
  call NetCDF_read_var(grp_ncid, "shdmax",  .False., input_shdmax)
  call NetCDF_read_var(grp_ncid, "zorlw",   .False., input_zorlw)
  call NetCDF_read_var(grp_ncid, "slmsk",   .False., input_slmsk)
  call NetCDF_read_var(grp_ncid, "canopy",  .False., input_canopy)
  call NetCDF_read_var(grp_ncid, "hice",    .False., input_hice)
  call NetCDF_read_var(grp_ncid, "fice",    .False., input_fice)
  call NetCDF_read_var(grp_ncid, "tisfc",   .False., input_tisfc)
  call NetCDF_read_var(grp_ncid, "snwdph",  .False., input_snwdph)
  call NetCDF_read_var(grp_ncid, "snoalb",  .False., input_snoalb)
  call NetCDF_read_var(grp_ncid, "tg3",     .False., input_tg3)
  call NetCDF_read_var(grp_ncid, "uustar",  .False., input_uustar)
  call NetCDF_read_var(grp_ncid, "alvsf",   .False., input_alvsf)
  call NetCDF_read_var(grp_ncid, "alnsf",   .False., input_alnsf)
  call NetCDF_read_var(grp_ncid, "alvwf",   .False., input_alvwf)
  call NetCDF_read_var(grp_ncid, "alnwf",   .False., input_alnwf)
  call NetCDF_read_var(grp_ncid, "facsf",   .False., input_facsf)
  call NetCDF_read_var(grp_ncid, "facwf",   .False., input_facwf)
  call NetCDF_read_var(grp_ncid, "weasd",   .False., input_weasd)
  call NetCDF_read_var(grp_ncid, "f10m",    .False., input_f10m)
  call NetCDF_read_var(grp_ncid, "t2m",     .False., input_t2m)
  call NetCDF_read_var(grp_ncid, "q2m",     .False., input_q2m)
  call NetCDF_read_var(grp_ncid, "ffmm",    .False., input_ffmm)
  call NetCDF_read_var(grp_ncid, "ffhh",    .False., input_ffhh)
  call NetCDF_read_var(grp_ncid, "tprcp",   .False., input_tprcp)
  call NetCDF_read_var(grp_ncid, "srflag",  .False., input_srflag)
  call NetCDF_read_var(grp_ncid, "sncovr",  .False., input_sncovr)
  call NetCDF_read_var(grp_ncid, "tsfcl",   .False., input_tsfcl)
  call NetCDF_read_var(grp_ncid, "zorll",   .False., input_zorll)
  call NetCDF_read_var(grp_ncid, "zorli",   .False., input_zorli)
  call NetCDF_read_var(grp_ncid, "zorlwav", .False., input_zorlwav)
  
  !orographic parameters
  call NetCDF_read_var(grp_ncid, "stddev",    .False., input_stddev)
  call NetCDF_read_var(grp_ncid, "convexity", .False., input_convexity)
  call NetCDF_read_var(grp_ncid, "oa1",       .False., input_oa1)
  call NetCDF_read_var(grp_ncid, "oa2",       .False., input_oa2)
  call NetCDF_read_var(grp_ncid, "oa3",       .False., input_oa3)
  call NetCDF_read_var(grp_ncid, "oa4",       .False., input_oa4)
  call NetCDF_read_var(grp_ncid, "ol1",       .False., input_ol1)
  call NetCDF_read_var(grp_ncid, "ol2",       .False., input_ol2)
  call NetCDF_read_var(grp_ncid, "ol3",       .False., input_ol3)
  call NetCDF_read_var(grp_ncid, "ol4",       .False., input_ol4)
  call NetCDF_read_var(grp_ncid, "theta",     .False., input_theta)
  call NetCDF_read_var(grp_ncid, "gamma",     .False., input_gamma)
  call NetCDF_read_var(grp_ncid, "sigma",     .False., input_sigma)
  call NetCDF_read_var(grp_ncid, "elvmax",    .False., input_elvmax)
  call NetCDF_read_var(grp_ncid, "oro",       .False., input_oro)
  call NetCDF_read_var(grp_ncid, "oro_uf",    .False., input_oro_uf)
  call NetCDF_read_var(grp_ncid, "landfrac",  .False., input_landfrac)
  call NetCDF_read_var(grp_ncid, "lakefrac",  .False., input_lakefrac)
  call NetCDF_read_var(grp_ncid, "lakedepth", .False., input_lakedepth)
  
  !NoahMP parameters
  call NetCDF_read_var(grp_ncid, "tvxy",      .False., input_tvxy)
  call NetCDF_read_var(grp_ncid, "tgxy",      .False., input_tgxy)
  call NetCDF_read_var(grp_ncid, "tahxy",     .False., input_tahxy)
  call NetCDF_read_var(grp_ncid, "canicexy",  .False., input_canicexy)
  call NetCDF_read_var(grp_ncid, "canliqxy",  .False., input_canliqxy)
  call NetCDF_read_var(grp_ncid, "eahxy",     .False., input_eahxy)
  call NetCDF_read_var(grp_ncid, "cmxy",      .False., input_cmxy)
  call NetCDF_read_var(grp_ncid, "chxy",      .False., input_chxy)
  call NetCDF_read_var(grp_ncid, "fwetxy",    .False., input_fwetxy)
  call NetCDF_read_var(grp_ncid, "sneqvoxy",  .False., input_sneqvoxy)
  call NetCDF_read_var(grp_ncid, "alboldxy",  .False., input_alboldxy)
  call NetCDF_read_var(grp_ncid, "qsnowxy",   .False., input_qsnowxy)
  call NetCDF_read_var(grp_ncid, "wslakexy",  .False., input_wslakexy)
  call NetCDF_read_var(grp_ncid, "taussxy",   .False., input_taussxy)
  call NetCDF_read_var(grp_ncid, "waxy",      .False., input_waxy)
  call NetCDF_read_var(grp_ncid, "wtxy",      .False., input_wtxy)
  call NetCDF_read_var(grp_ncid, "zwtxy",     .False., input_zwtxy)
  call NetCDF_read_var(grp_ncid, "xlaixy",    .False., input_xlaixy)
  call NetCDF_read_var(grp_ncid, "xsaixy",    .False., input_xsaixy)
  call NetCDF_read_var(grp_ncid, "lfmassxy",  .False., input_lfmassxy)
  call NetCDF_read_var(grp_ncid, "stmassxy",  .False., input_stmassxy)
  call NetCDF_read_var(grp_ncid, "rtmassxy",  .False., input_rtmassxy)
  call NetCDF_read_var(grp_ncid, "woodxy",    .False., input_woodxy)
  call NetCDF_read_var(grp_ncid, "stblcpxy",  .False., input_stblcpxy)
  call NetCDF_read_var(grp_ncid, "fastcpxy",  .False., input_fastcpxy)
  call NetCDF_read_var(grp_ncid, "smcwtdxy",  .False., input_smcwtdxy)
  call NetCDF_read_var(grp_ncid, "deeprechxy",.False., input_deeprechxy)
  call NetCDF_read_var(grp_ncid, "rechxy",    .False., input_rechxy)
  call NetCDF_read_var(grp_ncid, "snowxy",    .False., input_snowxy)
  call NetCDF_read_var(grp_ncid, "albdvis",   .False., input_albdvis)
  call NetCDF_read_var(grp_ncid, "albdnir",   .False., input_albdnir)
  call NetCDF_read_var(grp_ncid, "albivis",   .False., input_albivis)
  call NetCDF_read_var(grp_ncid, "albinir",   .False., input_albinir)
  call NetCDF_read_var(grp_ncid, "emiss",     .False., input_emiss)
  
  !NSST variables
  call NetCDF_read_var(grp_ncid, "tref",    .False., input_tref)
  call NetCDF_read_var(grp_ncid, "z_c",     .False., input_z_c)
  call NetCDF_read_var(grp_ncid, "c_0",     .False., input_c_0)
  call NetCDF_read_var(grp_ncid, "c_d",     .False., input_c_d)
  call NetCDF_read_var(grp_ncid, "w_0",     .False., input_w_0)
  call NetCDF_read_var(grp_ncid, "w_d",     .False., input_w_d)
  call NetCDF_read_var(grp_ncid, "xt",      .False., input_xt)
  call NetCDF_read_var(grp_ncid, "xs",      .False., input_xs)
  call NetCDF_read_var(grp_ncid, "xu",      .False., input_xu)
  call NetCDF_read_var(grp_ncid, "xv",      .False., input_xv)
  call NetCDF_read_var(grp_ncid, "xz",      .False., input_xz)
  call NetCDF_read_var(grp_ncid, "zm",      .False., input_zm)
  call NetCDF_read_var(grp_ncid, "xtts",    .False., input_xtts)
  call NetCDF_read_var(grp_ncid, "xzts",    .False., input_xzts)
  call NetCDF_read_var(grp_ncid, "d_conv",  .False., input_d_conv)
  call NetCDF_read_var(grp_ncid, "ifd",     .False., input_ifd)
  call NetCDF_read_var(grp_ncid, "dt_cool", .False., input_dt_cool)
  call NetCDF_read_var(grp_ncid, "qrain",   .False., input_qrain)
  
  !RUC LSM variables
  call NetCDF_read_var(grp_ncid, "wetness",          .False., input_wetness)
  call NetCDF_read_var(grp_ncid, "clw_surf_land",    .False., input_clw_surf_land)
  call NetCDF_read_var(grp_ncid, "clw_surf_ice",     .False., input_clw_surf_ice)
  call NetCDF_read_var(grp_ncid, "qwv_surf_land",    .False., input_qwv_surf_land)
  call NetCDF_read_var(grp_ncid, "qwv_surf_ice",     .False., input_qwv_surf_ice)
  call NetCDF_read_var(grp_ncid, "tsnow_land",       .False., input_tsnow_land)
  call NetCDF_read_var(grp_ncid, "tsnow_ice",        .False., input_tsnow_ice)
  call NetCDF_read_var(grp_ncid, "snowfall_acc_land",.False., input_snowfallac_land)
  call NetCDF_read_var(grp_ncid, "snowfall_acc_ice", .False., input_snowfallac_ice)
  call NetCDF_read_var(grp_ncid, "sncovr_ice",       .False., input_sncovr_ice)
  call NetCDF_read_var(grp_ncid, "lai",              .False., input_lai)
    
  !> - Read in the forcing data.

  !>  - Find group ncid for forcing group.
  call check(NF90_INQ_GRP_NCID(ncid,"forcing",grp_ncid))

  !>  - (Recall that multidimensional arrays need to be read in with the order of dimensions reversed from the netCDF file).

  !>  - Allocate the time-series and 2D forcing data.
  allocate(input_pres_surf(input_ntimes), input_T_surf(input_ntimes),            &
    input_sh_flux_sfc(input_ntimes), input_lh_flux_sfc(input_ntimes), input_w_ls(input_ntimes, input_nlev), &
    input_omega(input_ntimes, input_nlev), input_u_g(input_ntimes, input_nlev), input_v_g(input_ntimes, input_nlev), &
    input_dT_dt_rad(input_ntimes, input_nlev), input_h_advec_thetail(input_ntimes, input_nlev), &
    input_h_advec_qt(input_ntimes, input_nlev), input_v_advec_thetail(input_ntimes, input_nlev), &
    input_v_advec_qt(input_ntimes, input_nlev), input_u_nudge(input_ntimes, input_nlev), input_v_nudge(input_ntimes, input_nlev),  &
    input_T_nudge(input_ntimes, input_nlev), input_thil_nudge(input_ntimes, input_nlev), input_qt_nudge(input_ntimes, input_nlev), &
    stat=allocate_status)

  !>  - Read in the time-series and 2D forcing data.
  call NetCDF_read_var(grp_ncid, "p_surf", .True., input_pres_surf)
  call NetCDF_read_var(grp_ncid, "T_surf", .True., input_T_surf)
  call NetCDF_read_var(grp_ncid, "sh_flux_sfc", .False., input_sh_flux_sfc)
  call NetCDF_read_var(grp_ncid, "lh_flux_sfc", .False., input_lh_flux_sfc)
  
  call NetCDF_read_var(grp_ncid, "w_ls", .True., input_w_ls)
  call NetCDF_read_var(grp_ncid, "omega", .True., input_omega)
  call NetCDF_read_var(grp_ncid, "u_g", .True., input_u_g)
  call NetCDF_read_var(grp_ncid, "v_g", .True., input_v_g)
  call NetCDF_read_var(grp_ncid, "u_nudge", .True., input_u_nudge)
  call NetCDF_read_var(grp_ncid, "v_nudge", .True., input_v_nudge)
  call NetCDF_read_var(grp_ncid, "T_nudge", .True., input_T_nudge)
  call NetCDF_read_var(grp_ncid, "thil_nudge", .True., input_thil_nudge)
  call NetCDF_read_var(grp_ncid, "qt_nudge", .True., input_qt_nudge)
  call NetCDF_read_var(grp_ncid, "dT_dt_rad", .True., input_dT_dt_rad)
  call NetCDF_read_var(grp_ncid, "h_advec_thetail", .True., input_h_advec_thetail)
  call NetCDF_read_var(grp_ncid, "h_advec_qt", .True., input_h_advec_qt)
  call NetCDF_read_var(grp_ncid, "v_advec_thetail", .True., input_v_advec_thetail)
  call NetCDF_read_var(grp_ncid, "v_advec_qt", .True., input_v_advec_qt)

  call check(NF90_CLOSE(NCID=ncid))

  call scm_input%create(input_ntimes, input_nlev, input_nsoil, input_nsnow, input_nice)
    
  ! GJF already done in scm_input%create routine
  !scm_input%input_nlev = input_nlev
  !scm_input%input_ntimes = input_ntimes

  scm_input%input_pres = input_pres
  scm_input%input_time = input_time
  scm_input%input_temp = input_temp
  scm_input%input_thetail = input_thetail
  scm_input%input_qt = input_qt
  scm_input%input_ql = input_ql
  scm_input%input_qi = input_qi
  scm_input%input_u = input_u
  scm_input%input_v = input_v
  scm_input%input_tke = input_tke
  scm_input%input_ozone = input_ozone
  scm_input%input_lat = input_lat
  scm_input%input_lon = input_lon
  scm_input%input_pres_surf = input_pres_surf
  scm_input%input_T_surf = input_T_surf
  scm_input%input_sh_flux_sfc_kin = input_sh_flux_sfc
  scm_input%input_lh_flux_sfc_kin = input_lh_flux_sfc
  scm_input%input_w_ls = input_w_ls
  scm_input%input_omega = input_omega
  scm_input%input_u_g = input_u_g
  scm_input%input_v_g = input_v_g
  scm_input%input_dT_dt_rad = input_dT_dt_rad
  scm_input%input_h_advec_thetail = input_h_advec_thetail
  scm_input%input_h_advec_qt = input_h_advec_qt
  scm_input%input_v_advec_thetail = input_v_advec_thetail
  scm_input%input_v_advec_qt = input_v_advec_qt
  scm_input%input_u_nudge = input_u_nudge
  scm_input%input_v_nudge = input_v_nudge
  scm_input%input_T_nudge = input_T_nudge
  scm_input%input_thil_nudge = input_thil_nudge
  scm_input%input_qt_nudge = input_qt_nudge
  
  scm_input%input_stc   = input_stc  
  scm_input%input_smc   = input_smc  
  scm_input%input_slc   = input_slc  
  
  scm_input%input_snicexy    = input_snicexy
  scm_input%input_snliqxy    = input_snliqxy
  scm_input%input_tsnoxy     = input_tsnoxy
  scm_input%input_smoiseq    = input_smoiseq
  scm_input%input_zsnsoxy    = input_zsnsoxy
  
  scm_input%input_tiice      = input_tiice
  scm_input%input_tslb       = input_tslb
  scm_input%input_smois      = input_smois
  scm_input%input_sh2o       = input_sh2o
  scm_input%input_smfr       = input_smfr
  scm_input%input_flfr       = input_flfr
  
  scm_input%input_vegsrc   = input_vegsrc
  scm_input%input_vegtyp   = input_vegtyp
  scm_input%input_soiltyp  = input_soiltyp
  scm_input%input_slopetype = input_slopetype
  scm_input%input_tsfco    = input_tsfco
  scm_input%input_vegfrac  = input_vegfrac
  scm_input%input_shdmin   = input_shdmin
  scm_input%input_shdmax   = input_shdmax
  scm_input%input_zorlw    = input_zorlw
  scm_input%input_slmsk    = input_slmsk
  scm_input%input_canopy   = input_canopy
  scm_input%input_hice     = input_hice
  scm_input%input_fice     = input_fice
  scm_input%input_tisfc    = input_tisfc
  scm_input%input_snwdph   = input_snwdph
  scm_input%input_snoalb   = input_snoalb
  scm_input%input_sncovr   = input_sncovr
  scm_input%input_area     = input_area
  scm_input%input_tg3      = input_tg3
  scm_input%input_uustar   = input_uustar
  scm_input%input_alvsf    = input_alvsf
  scm_input%input_alnsf    = input_alnsf
  scm_input%input_alvwf    = input_alvwf
  scm_input%input_alnwf    = input_alnwf
  scm_input%input_facsf    = input_facsf
  scm_input%input_facwf    = input_facwf
  scm_input%input_weasd    = input_weasd
  scm_input%input_f10m     = input_f10m
  scm_input%input_t2m      = input_t2m
  scm_input%input_q2m      = input_q2m
  scm_input%input_ffmm     = input_ffmm
  scm_input%input_ffhh     = input_ffhh
  scm_input%input_tprcp    = input_tprcp
  scm_input%input_srflag   = input_srflag
  scm_input%input_tsfcl    = input_tsfcl
  scm_input%input_zorll    = input_zorll
  scm_input%input_zorli    = input_zorli
  scm_input%input_zorlwav  = input_zorlwav
  
  scm_input%input_stddev   = input_stddev
  scm_input%input_convexity= input_convexity
  scm_input%input_oa1      = input_oa1
  scm_input%input_oa2      = input_oa2
  scm_input%input_oa3      = input_oa3
  scm_input%input_oa4      = input_oa4
  scm_input%input_ol1      = input_ol1
  scm_input%input_ol2      = input_ol2
  scm_input%input_ol3      = input_ol3
  scm_input%input_ol4      = input_ol4
  scm_input%input_sigma    = input_sigma
  scm_input%input_theta    = input_theta
  scm_input%input_gamma    = input_gamma
  scm_input%input_elvmax   = input_elvmax
  scm_input%input_oro      = input_oro
  scm_input%input_oro_uf   = input_oro_uf
  scm_input%input_landfrac = input_landfrac
  scm_input%input_lakefrac = input_lakefrac
  scm_input%input_lakedepth= input_lakedepth
  
  scm_input%input_tvxy = input_tvxy
  scm_input%input_tgxy = input_tgxy
  scm_input%input_tahxy = input_tahxy
  scm_input%input_canicexy = input_canicexy
  scm_input%input_canliqxy = input_canliqxy
  scm_input%input_eahxy = input_eahxy
  scm_input%input_cmxy = input_cmxy
  scm_input%input_chxy = input_chxy
  scm_input%input_fwetxy = input_fwetxy
  scm_input%input_sneqvoxy = input_sneqvoxy
  scm_input%input_alboldxy = input_alboldxy
  scm_input%input_qsnowxy = input_qsnowxy
  scm_input%input_wslakexy = input_wslakexy
  scm_input%input_taussxy = input_taussxy
  scm_input%input_waxy = input_waxy
  scm_input%input_wtxy = input_wtxy
  scm_input%input_zwtxy = input_zwtxy
  scm_input%input_xlaixy = input_xlaixy
  scm_input%input_xsaixy = input_xsaixy
  scm_input%input_lfmassxy = input_lfmassxy
  scm_input%input_stmassxy = input_stmassxy
  scm_input%input_rtmassxy = input_rtmassxy
  scm_input%input_woodxy = input_woodxy
  scm_input%input_stblcpxy = input_stblcpxy
  scm_input%input_fastcpxy = input_fastcpxy
  scm_input%input_smcwtdxy = input_smcwtdxy
  scm_input%input_deeprechxy = input_deeprechxy
  scm_input%input_rechxy = input_rechxy
  scm_input%input_snowxy = input_snowxy
  scm_input%input_albdvis = input_albdvis
  scm_input%input_albdnir = input_albdnir
  scm_input%input_albivis = input_albivis
  scm_input%input_albinir = input_albinir
  scm_input%input_emiss = input_emiss
  
  scm_input%input_tref    = input_tref
  scm_input%input_z_c     = input_z_c
  scm_input%input_c_0     = input_c_0
  scm_input%input_c_d     = input_c_d
  scm_input%input_w_0     = input_w_0
  scm_input%input_w_d     = input_w_d
  scm_input%input_xt      = input_xt
  scm_input%input_xs      = input_xs
  scm_input%input_xu      = input_xu
  scm_input%input_xv      = input_xv
  scm_input%input_xz      = input_xz
  scm_input%input_zm      = input_zm
  scm_input%input_xtts    = input_xtts
  scm_input%input_xzts    = input_xzts
  scm_input%input_d_conv  = input_d_conv
  scm_input%input_ifd     = input_ifd
  scm_input%input_dt_cool = input_dt_cool
  scm_input%input_qrain   = input_qrain
  
  scm_input%input_wetness         = input_wetness
  scm_input%input_clw_surf_land   = input_clw_surf_land
  scm_input%input_clw_surf_ice    = input_clw_surf_ice
  scm_input%input_qwv_surf_land   = input_qwv_surf_land
  scm_input%input_qwv_surf_ice    = input_qwv_surf_ice
  scm_input%input_tsnow_land      = input_tsnow_land
  scm_input%input_tsnow_ice       = input_tsnow_ice
  scm_input%input_snowfallac_land = input_snowfallac_land
  scm_input%input_snowfallac_ice  = input_snowfallac_ice
  scm_input%input_sncovr_ice      = input_sncovr_ice
  scm_input%input_lai             = input_lai
  
!> @}
end subroutine get_case_init

subroutine get_case_init_DEPHY(scm_state, scm_input)
  !corresponds to the DEPHY-SCM specs, version 1
  
  use scm_type_defs, only : scm_state_type, scm_input_type
  use NetCDF_read, only: NetCDF_read_var, NetCDF_read_att, NetCDF_conditionally_read_var, check, missing_value, missing_value_int
  use scm_physical_constants, only: con_hvap, con_hfus, con_cp, con_rocp, con_rd
  use scm_utils, only: find_vertical_index_pressure, find_vertical_index_height
  
  type(scm_state_type), intent(inout) :: scm_state
  type(scm_input_type), target, intent(inout) :: scm_input
  
  ! dimension variables
  real(kind=dp), allocatable  :: input_t0(:) !< input initialization times (seconds since global attribute "startdate")
  real(kind=dp), allocatable  :: input_time(:) !< input forcing times (seconds since the beginning of the case)
  real(kind=dp), allocatable  :: input_lat(:) !< column latitude (deg)
  real(kind=dp), allocatable  :: input_lon(:) !< column longitude (deg)
  real(kind=dp), allocatable  :: input_lev(:) !< corresponds to either pressure or height (depending on attribute) - why is this needed when both pressure and height also provided in ICs?
  
  ! global attributes
  character(len=14)    :: char_startDate, char_endDate !format YYYYMMDDHHMMSS
  integer :: init_year, init_month, init_day, init_hour, init_min, init_sec, end_year, end_month, end_day, end_hour, end_min, end_sec
  integer :: adv_u, adv_v, adv_temp, adv_theta, adv_thetal, adv_qv, adv_qt, adv_rv, adv_rt, forc_w, forc_omega, forc_geo
  integer :: rad_temp, rad_theta, rad_thetal
  character(len=3) :: char_rad_temp, char_rad_theta, char_rad_thetal
  integer :: nudging_temp, nudging_theta, nudging_thetal, nudging_qv, nudging_qt, nudging_rv, nudging_rt, nudging_u, nudging_v
  real(kind=sp) :: z_nudging_temp, z_nudging_theta, z_nudging_thetal, z_nudging_qv, z_nudging_qt, z_nudging_rv, z_nudging_rt, z_nudging_u, z_nudging_v
  real(kind=sp) :: p_nudging_temp, p_nudging_theta, p_nudging_thetal, p_nudging_qv, p_nudging_qt, p_nudging_rv, p_nudging_rt, p_nudging_u, p_nudging_v
  real(kind=sp) :: input_zorog, input_z0
  character(len=5) :: input_surfaceType
  character(len=11) :: input_surfaceForcing
  character(len=5) :: input_surfaceForcingWind
  
  ! initial variables (IC = Initial Condition)
  real(kind=sp), allocatable :: input_pres(:,:,:,:) !< IC pressure levels (Pa)
  real(kind=sp), allocatable :: input_height(:,:,:,:) !< IC height levels (m)
  real(kind=sp), allocatable :: input_pres_surf(:,:,:) !< IC surface pressure (Pa)
  real(kind=sp), allocatable :: input_u(:,:,:,:) !< IC east-west horizontal wind profile (m s^-1)
  real(kind=sp), allocatable :: input_v(:,:,:,:) !< IC north-south horizontal wind profile (m s^-1)
  real(kind=sp), allocatable :: input_temp(:,:,:,:) !< IC temperature profile (K)
  real(kind=sp), allocatable :: input_theta(:,:,:,:) !< IC potential temperature profile (K)
  real(kind=sp), allocatable :: input_thetal(:,:,:,:) !< IC liquid potential temperature profile (K)
  real(kind=sp), allocatable :: input_qv(:,:,:,:) !< IC specific humidity profile (kg kg^-1)
  real(kind=sp), allocatable :: input_qt(:,:,:,:) !< IC total water specific humidity profile (kg kg^-1)
  real(kind=sp), allocatable :: input_ql(:,:,:,:) !< IC liquid water specific humidity profile (kg kg^-1)
  real(kind=sp), allocatable :: input_qi(:,:,:,:) !< IC ice water specific humidity profile (kg kg^-1)
  real(kind=sp), allocatable :: input_rv(:,:,:,:) !< IC water vapor mixing ratio profile (kg kg^-1)
  real(kind=sp), allocatable :: input_rt(:,:,:,:) !< IC total water mixing ratio profile (kg kg^-1)
  real(kind=sp), allocatable :: input_rl(:,:,:,:) !< IC liquid water mixing ratio profile (kg kg^-1)
  real(kind=sp), allocatable :: input_ri(:,:,:,:) !< IC ice water mixing ratio profile (kg kg^-1)
  real(kind=sp), allocatable :: input_rh(:,:,:,:) !< IC relative humidity profile (%)
  real(kind=sp), allocatable :: input_tke(:,:,:,:) !< IC TKE profile (m^2 s^-2)
  
  ! forcing variables
  real(kind=sp), allocatable :: input_force_pres_surf(:,:,:) !< forcing surface pressure (Pa)
  real(kind=sp), allocatable :: input_force_height(:,:,:,:) !< forcing height levels (m)
  real(kind=sp), allocatable :: input_force_pres(:,:,:,:) !< forcing pressure levels (Pa)
  real(kind=sp), allocatable :: input_force_u_g(:,:,:,:) !< forcing 2D geostrophic east-west wind (m s^-1)
  real(kind=sp), allocatable :: input_force_v_g(:,:,:,:) !< forcing 2D geostrophic north-south wind (m s^-1)
  real(kind=sp), allocatable :: input_force_w(:,:,:,:)
  real(kind=sp), allocatable :: input_force_omega(:,:,:,:)
  real(kind=sp), allocatable :: input_force_u_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_v_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_temp_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_theta_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_thetal_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_qt_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_qv_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_rt_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_rv_adv(:,:,:,:)
  real(kind=sp), allocatable :: input_force_temp_rad(:,:,:,:)
  real(kind=sp), allocatable :: input_force_theta_rad(:,:,:,:)
  real(kind=sp), allocatable :: input_force_thetal_rad(:,:,:,:)
  real(kind=sp), allocatable :: input_force_sfc_sens_flx(:,:,:)
  real(kind=sp), allocatable :: input_force_sfc_lat_flx(:,:,:)
  real(kind=sp), allocatable :: input_force_wpthetap(:,:,:)
  real(kind=sp), allocatable :: input_force_wpqvp(:,:,:)
  real(kind=sp), allocatable :: input_force_wpqtp(:,:,:)
  real(kind=sp), allocatable :: input_force_wprvp(:,:,:)
  real(kind=sp), allocatable :: input_force_wprtp(:,:,:)
  real(kind=sp), allocatable :: input_force_ts(:,:,:)
  real(kind=sp), allocatable :: input_force_ustar(:,:,:)
  real(kind=sp), allocatable :: input_force_temp_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_theta_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_thetal_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_qv_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_qt_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_rv_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_rt_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_u_nudging(:,:,:,:)
  real(kind=sp), allocatable :: input_force_v_nudging(:,:,:,:)
  
  integer :: ncid, varID, allocate_status, ierr, i, k
  integer :: active_lon, active_lat, active_init_time
  CHARACTER(LEN=nf90_max_name) :: tmpName
  real(kind=sp), parameter :: p0 = 100000.0
  real(kind=sp) :: exner, exner_inv, rho, elapsed_sec, missing_value_eps
  real(kind=dp) :: rinc(5)
  integer :: jdat(1:8), idat(1:8) !(yr, mon, day, t-zone, hr, min, sec, mil-sec)
  
  integer :: input_n_init_times, input_n_forcing_times, input_n_lev, input_n_lat, input_n_lon, input_n_snow, input_n_ice, input_n_soil
  
  missing_value_eps = missing_value + 0.01
  
  !> - Open the case input file found in the processed_case_input dir corresponding to the experiment name.
  call check(NF90_OPEN(trim(adjustl(scm_state%case_data_dir))//'/'//trim(adjustl(scm_state%case_name))//'_SCM_driver.nc',nf90_nowrite,ncid))
  
  !> - Get the dimensions.
  
  !required dimensions
  call check(NF90_INQ_DIMID(ncid,"t0",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_init_times))
  call check(NF90_INQ_DIMID(ncid,"time",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_forcing_times))
  call check(NF90_INQ_DIMID(ncid,"lev",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_lev))
  !Check whether long_name = 'altitude', units='m' OR long_name = 'pressure', units='Pa'?
  !It may not matter, because 'lev' may not be needed when the IC pressure and height are BOTH already provided
  call check(NF90_INQ_DIMID(ncid,"lat",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_lat))
  call check(NF90_INQ_DIMID(ncid,"lon",varID))
  call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_lon))
  
  !### TO BE USED IF DEPHY-SCM can be extended to include model ICs ###
  !possible dimensions (if using model ICs)
  ierr = NF90_INQ_DIMID(ncid,"nsoil",varID)
  if(ierr /= NF90_NOERR) then
    input_n_soil = missing_soil_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_soil))
  end if
  ierr = NF90_INQ_DIMID(ncid,"nsnow",varID)
  if(ierr /= NF90_NOERR) then
    input_n_snow = missing_snow_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_snow))
  end if
  ierr = NF90_INQ_DIMID(ncid,"nice",varID)
  if(ierr /= NF90_NOERR) then
    input_n_ice = missing_ice_layers
  else
    call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, input_n_ice))
  end if  
  
  !> - Allocate the dimension variables.
  allocate(input_t0    (input_n_init_times),                                        &
           input_time  (input_n_forcing_times),                                     &
           input_lat   (input_n_lat),                                               &
           input_lon   (input_n_lon),                                               &
           input_lev   (input_n_lev),                                               &
    stat=allocate_status)

  !> - Read in the dimension variables (required).
  call NetCDF_read_var(ncid, "t0", .True., input_t0)
  call NetCDF_read_var(ncid, "time", .True., input_time)
  call NetCDF_read_var(ncid, "lev", .True., input_lev)
  call NetCDF_read_var(ncid, "lat", .True., input_lat)
  call NetCDF_read_var(ncid, "lon", .True., input_lon)
  
  !> - Read in global attributes

  call NetCDF_read_att(ncid, NF90_GLOBAL, 'startDate', .True., char_startDate)
    
  read(char_startDate(1:4),'(i4)')   init_year
  read(char_startDate(5:6),'(i2)')   init_month
  read(char_startDate(7:8),'(i2)')   init_day
  read(char_startDate(9:10),'(i2)')  init_hour
  read(char_startDate(11:12),'(i2)') init_min
  read(char_startDate(13:14),'(i2)') init_sec
  
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'endDate', .True., char_endDate)
  
  read(char_endDate(1:4),'(i4)')   end_year
  read(char_endDate(5:6),'(i2)')   end_month
  read(char_endDate(7:8),'(i2)')   end_day
  read(char_endDate(9:10),'(i2)')  end_hour
  read(char_endDate(11:12),'(i2)') end_min
  read(char_endDate(13:14),'(i2)') end_sec
  
  !compare init time to what was in case config file? replace?
  
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_u',              .False., adv_u)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_v',              .False., adv_v)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_temp',           .False., adv_temp)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_theta',          .False., adv_theta)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_thetal',         .False., adv_thetal)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'rad_temp',           .False., rad_temp, char_rad_temp)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'rad_theta',          .False., rad_theta, char_rad_theta)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'rad_thetal',         .False., rad_thetal, char_rad_thetal)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_qv',             .False., adv_qv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_qt',             .False., adv_qt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_rv',             .False., adv_rv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'adv_rt',             .False., adv_rt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'forc_w',             .False., forc_w)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'forc_omega',         .False., forc_omega)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'forc_geo',           .False., forc_geo)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_temp',       .False., nudging_temp)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_theta',      .False., nudging_theta)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_thetal',     .False., nudging_thetal)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_qv',         .False., nudging_qv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_qt',         .False., nudging_qt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_rv',         .False., nudging_rv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_rt',         .False., nudging_rt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_u',          .False., nudging_u)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'nudging_v',          .False., nudging_v)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_temp',     .False., z_nudging_temp)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_theta',    .False., z_nudging_theta)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_thetal',   .False., z_nudging_thetal)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_qv',       .False., z_nudging_qv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_qt',       .False., z_nudging_qt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_rv',       .False., z_nudging_rv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_rt',       .False., z_nudging_rt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_u',        .False., z_nudging_u)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z_nudging_v',        .False., z_nudging_v)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_temp',     .False., p_nudging_temp)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_theta',    .False., p_nudging_theta)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_thetal',   .False., p_nudging_thetal)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_qv',       .False., p_nudging_qv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_qt',       .False., p_nudging_qt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_rv',       .False., p_nudging_rv)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_rt',       .False., p_nudging_rt)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_u',        .False., p_nudging_u)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'p_nudging_v',        .False., p_nudging_v)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'zorog',              .False., input_zorog)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'z0',                 .False., input_z0)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'surfaceType',        .False., input_surfaceType)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'surfaceForcing',     .False., input_surfaceForcing)
  call NetCDF_read_att(ncid, NF90_GLOBAL, 'surfaceForcingWind', .False., input_surfaceForcingWind)
  
  !> - Allocate the initial variables.
  allocate(input_pres     (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_height   (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_pres_surf(input_n_lon, input_n_lat, input_n_init_times),              &
           input_u        (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_v        (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_temp     (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_theta    (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_thetal   (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_qv       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_qt       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_ql       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_qi       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_rv       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_rt       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_rl       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_ri       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_rh       (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
           input_tke      (input_n_lon, input_n_lat, input_n_lev, input_n_init_times), &
    stat=allocate_status)
  
  !>  - Read in the initial profiles.
  
  call NetCDF_read_var(ncid, "pressure", .True., input_pres)
  call NetCDF_read_var(ncid, "height", .True., input_height)
  call NetCDF_read_var(ncid, "ps", .True., input_pres_surf)
  call NetCDF_read_var(ncid, "u", .True., input_u)
  call NetCDF_read_var(ncid, "v", .True., input_v)
  
  !one of the following should be present, but not all, hence they are not requried
  call NetCDF_read_var(ncid, "temp", .False., input_temp)
  call NetCDF_read_var(ncid, "theta", .False., input_theta)
  call NetCDF_read_var(ncid, "thetal", .False., input_thetal)
  
  !one or more of the following should be present, but not all, hence they are not requried
  call NetCDF_read_var(ncid, "qv", .False., input_qv)
  call NetCDF_read_var(ncid, "qt", .False., input_qt)
  call NetCDF_read_var(ncid, "ql", .False., input_ql)
  call NetCDF_read_var(ncid, "qi", .False., input_qi)
  call NetCDF_read_var(ncid, "rv", .False., input_rv)
  call NetCDF_read_var(ncid, "rt", .False., input_rt)
  call NetCDF_read_var(ncid, "rl", .False., input_rl)
  call NetCDF_read_var(ncid, "ri", .False., input_ri)
  call NetCDF_read_var(ncid, "rh", .False., input_rh)
  
  call NetCDF_read_var(ncid, "tke", .True., input_tke)
  
  !> - Allocate the forcing variables.
  
  !allocate all, but conditionally read forcing variables given global atts; set unused forcing variables to missing
  
  allocate(input_force_pres_surf  (input_n_lon, input_n_lat, input_n_forcing_times),              &
           input_force_pres       (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_height     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_u_g        (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_v_g        (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_w          (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_omega      (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_u_adv      (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_v_adv      (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_temp_adv   (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_theta_adv  (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_thetal_adv (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_qt_adv     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_qv_adv     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_rt_adv     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_rv_adv     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_temp_rad   (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_theta_rad  (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_thetal_rad (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_sfc_sens_flx (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_sfc_lat_flx  (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_wpthetap     (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_wpqvp        (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_wpqtp        (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_wprvp        (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_wprtp        (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_ts           (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_ustar        (input_n_lon, input_n_lat, input_n_forcing_times),            &
           input_force_u_nudging      (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_v_nudging      (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_temp_nudging   (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_theta_nudging  (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_thetal_nudging (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_qt_nudging     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_qv_nudging     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_rt_nudging     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
           input_force_rv_nudging     (input_n_lon, input_n_lat, input_n_lev, input_n_forcing_times), &
    stat=allocate_status)
  
  call NetCDF_read_var(ncid, "ps_forc", .True., input_force_pres_surf)
  call NetCDF_read_var(ncid, "height_forc", .True., input_force_height)
  call NetCDF_read_var(ncid, "pressure_forc", .True., input_force_pres) !existing code assumes this is equal to the initial condition pressure
  
  !conditionally read forcing vars (or set to missing); if the global attribute is set to expect a variable and it doesn't exist, stop the model
  call NetCDF_conditionally_read_var(adv_u,      "adv_u",      "u_adv",      trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_u_adv)
  call NetCDF_conditionally_read_var(adv_v,      "adv_v",      "v_adv",      trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_v_adv)
  call NetCDF_conditionally_read_var(adv_temp,   "adv_temp",   "temp_adv",   trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_temp_adv)
  call NetCDF_conditionally_read_var(adv_theta,  "adv_theta",  "theta_adv",  trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_theta_adv)
  call NetCDF_conditionally_read_var(adv_thetal, "adv_thetal", "thetal_adv", trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_thetal_adv)
  call NetCDF_conditionally_read_var(adv_qt,     "adv_qt",     "qt_adv",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_qt_adv)
  call NetCDF_conditionally_read_var(adv_qv,     "adv_qv",     "qv_adv",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_qv_adv)
  call NetCDF_conditionally_read_var(adv_rt,     "adv_rt",     "rt_adv",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_rt_adv)
  call NetCDF_conditionally_read_var(adv_rv,     "adv_rv",     "rv_adv",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_rv_adv)
  
  call NetCDF_conditionally_read_var(rad_temp,   "rad_temp",   "temp_rad",   trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_temp_rad)
  call NetCDF_conditionally_read_var(rad_theta,  "rad_theta",  "theta_rad",  trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_theta_rad)
  call NetCDF_conditionally_read_var(rad_thetal, "rad_thetal", "thetal_rad", trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_thetal_rad)
  !need to also handle the case when rad_[temp,theta,thetal]_char = 'adv' (make sure [temp,theta,thetal]_adv is not missing)
  !need to also turn off radiation when radiation is being forced (put in a warning that this is not supported for now?)
  
  call NetCDF_conditionally_read_var(forc_w,     "forc_w",   "w",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_w)
  call NetCDF_conditionally_read_var(forc_omega, "forc_w",   "omega", trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_omega)
  call NetCDF_conditionally_read_var(forc_geo,   "forc_geo", "ug",    trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_u_g)
  call NetCDF_conditionally_read_var(forc_geo,   "forc_geo", "vg",    trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_v_g)
  
  call NetCDF_conditionally_read_var(nudging_u,      "nudging_u",      "u_nudging",      trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_u_nudging)
  call NetCDF_conditionally_read_var(nudging_v,      "nudging_v",      "v_nudging",      trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_v_nudging)
  call NetCDF_conditionally_read_var(nudging_temp,   "nudging_temp",   "temp_nudging",   trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_temp_nudging)
  call NetCDF_conditionally_read_var(nudging_theta,  "nudging_theta",  "theta_nudging",  trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_theta_nudging)
  call NetCDF_conditionally_read_var(nudging_thetal, "nudging_thetal", "thetal_nudging", trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_thetal_nudging)
  call NetCDF_conditionally_read_var(nudging_qv,     "nudging_qv",     "qv_nudging",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_qv_nudging)
  call NetCDF_conditionally_read_var(nudging_qt,     "nudging_qt",     "qt_nudging",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_qt_nudging)
  call NetCDF_conditionally_read_var(nudging_rv,     "nudging_rv",     "rv_nudging",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_rv_nudging)
  call NetCDF_conditionally_read_var(nudging_rt,     "nudging_rt",     "rt_nudging",     trim(adjustl(scm_state%case_name))//'.nc', ncid, input_force_rt_nudging)
  
  if (input_surfaceForcing == 'Flux') then
    !read kinematic surface flux variables
    call NetCDF_read_var(ncid, "wpthetap", .False., input_force_wpthetap)
    call NetCDF_read_var(ncid, "wpqvp", .False., input_force_wpqvp)
    call NetCDF_read_var(ncid, "wpqtp", .False., input_force_wpqtp)
    call NetCDF_read_var(ncid, "wprvp", .False., input_force_wprvp)
    call NetCDF_read_var(ncid, "wprtp", .False., input_force_wprtp)
    !try to read in ts when surface fluxes are specified (needed for calculating bulk-Richardson number in specified surface flux scheme)
    call NetCDF_read_var(ncid, "ts", .False., input_force_ts)
  else if (input_surfaceForcing == 'surfaceFlux') then
    !read W/m2 variables
    call NetCDF_read_var(ncid, "sfc_sens_flx", .False., input_force_sfc_sens_flx)
    call NetCDF_read_var(ncid, "sfc_lat_flx", .False., input_force_sfc_lat_flx)
    !try to read in ts when surface fluxes are in W m-2 in order to be able to convert to kinematic (also needed for calculating bulk-Richardson number in specified surface flux scheme)
    call NetCDF_read_var(ncid, "ts", .False., input_force_ts)
  else if (input_surfaceForcing == 'ts') then
    !read surface temperature
    call NetCDF_read_var(ncid, "ts", .False., input_force_ts)
  end if
  
  if (input_surfaceForcingWind == 'z0') then
    !check that z0 was not missing in the global attributes
    if (input_z0 < 0) then
      write(*,*) 'The global attribute surfaceForcingWind in '//trim(adjustl(scm_state%case_name))//'.nc indicates that the global attribute z0 should be present, but it is missing. Stopping ...'
      stop
    end if
  else if (input_surfaceForcingWind == 'ustar') then
    call NetCDF_read_var(ncid, "ustar", .False., input_force_ustar)
  end if
  
  call check(NF90_CLOSE(NCID=ncid))
  
  call scm_input%create(input_n_forcing_times, input_n_lev, input_n_soil, input_n_snow, input_n_ice)
  
  !fill the scm_input DDT
  
  !There may need to be logic to control which of the lon, lat, and init_times to use in the future, but for now, just take the first
  active_lon = 1
  active_lat = 1
  active_init_time = 1
  
  rinc(1:5)   = 0
  idat = 0
  jdat = 0
  idat(1) = init_year
  idat(2) = init_month
  idat(3) = init_day
  idat(5) = init_hour
  idat(6) = init_min
  idat(7) = init_sec
  jdat(1) = end_year
  jdat(2) = end_month
  jdat(3) = end_day
  jdat(5) = end_hour
  jdat(6) = end_min
  jdat(7) = end_sec
  call w3difdat(jdat,idat,4,rinc)
  elapsed_sec = rinc(4)
  
  !the following variables replace what is in the case configuration file
  scm_state%init_year = init_year
  scm_state%init_month = init_month
  scm_state%init_day = init_day
  scm_state%init_hour = init_hour
  scm_state%init_min = init_min
  scm_state%runtime = elapsed_sec
  
  scm_input%input_time = input_time
  scm_input%input_pres_surf(1) = input_pres_surf(active_lon,active_lat,active_init_time) !perhaps input_pres_surf should only be equal to input_force_pres_surf?
  scm_input%input_pres = input_pres(active_lon,active_lat,:,active_init_time)
  scm_input%input_u = input_u(active_lon,active_lat,:,active_init_time)
  scm_input%input_v = input_v(active_lon,active_lat,:,active_init_time)
  scm_input%input_tke = input_tke(active_lon,active_lat,:,active_init_time)
  
  !if mixing ratios are present, and not specific humidities, convert from mixing ratio to specific humidities
  if ((maxval(input_qv(active_lon,active_lat,:,active_init_time)) < 0 .and. &
       maxval(input_qt(active_lon,active_lat,:,active_init_time)) < 0) .and. &
      (maxval(input_rv(active_lon,active_lat,:,active_init_time)) > 0 .or. &
       maxval(input_rt(active_lon,active_lat,:,active_init_time)) > 0)) then
     if (maxval(input_rv(active_lon,active_lat,:,active_init_time)) > 0) then
       do k=1, input_n_lev
         input_qv(active_lon,active_lat,k,active_init_time) = input_rv(active_lon,active_lat,k,active_init_time)/&
            (1.0 + input_rv(active_lon,active_lat,k,active_init_time))
       end do
     end if
     if (maxval(input_rt(active_lon,active_lat,:,active_init_time)) > 0) then
       do k=1, input_n_lev
         input_qt(active_lon,active_lat,k,active_init_time) = input_rt(active_lon,active_lat,k,active_init_time)/&
            (1.0 + input_rt(active_lon,active_lat,k,active_init_time))
       end do
     end if
     if (maxval(input_rl(active_lon,active_lat,:,active_init_time)) > 0) then
       do k=1, input_n_lev
         input_ql(active_lon,active_lat,k,active_init_time) = input_rl(active_lon,active_lat,k,active_init_time)/&
            (1.0 + input_rl(active_lon,active_lat,k,active_init_time))
       end do
     end if
     if (maxval(input_ri(active_lon,active_lat,:,active_init_time)) > 0) then
       do k=1, input_n_lev
         input_qi(active_lon,active_lat,k,active_init_time) = input_ri(active_lon,active_lat,k,active_init_time)/&
            (1.0 + input_ri(active_lon,active_lat,k,active_init_time))
       end do
     end if
  end if
  
  !make sure that one of qv or qt (and rv or rt due to above conversion) is present (add support for rh later)
  if (maxval(input_qv(active_lon,active_lat,:,active_init_time)) >= 0) then
    if (maxval(input_qt(active_lon,active_lat,:,active_init_time)) >= 0) then
      if (maxval(input_ql(active_lon,active_lat,:,active_init_time)) >= 0) then
        if (maxval(input_qi(active_lon,active_lat,:,active_init_time)) >= 0) then
          !all of qv, qt, ql, qi (need to check for consistency that they add up correctly?)
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
          scm_input%input_ql = input_ql(active_lon,active_lat,:,active_init_time)
          scm_input%input_qi = input_qi(active_lon,active_lat,:,active_init_time)
        else !qv, qt, ql, but not qi
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
          scm_input%input_ql = input_ql(active_lon,active_lat,:,active_init_time)
          !derive qi
          do k=1, input_n_lev
            scm_input%input_qi(k) = max(0.0, scm_input%input_qt(k) - scm_input%input_qv(k) - scm_input%input_ql(k))
          end do
        end if !qi test
      else 
        if (maxval(input_qi(active_lon,active_lat,:,active_init_time)) >= 0) then !qv, qt, qi, but no ql
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
          scm_input%input_qi = input_qi(active_lon,active_lat,:,active_init_time)
          !derive ql
          do k=1, input_n_lev
            scm_input%input_ql(k) = max(0.0, scm_input%input_qt(k) - scm_input%input_qv(k) - scm_input%input_qi(k))
          end do
        else !qv, qt, no ql or qi
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
          !assume that all cloud is liquid for now (could implement partitioning later)
          do k=1, input_n_lev
            scm_input%input_ql(k) = max(0.0, scm_input%input_qt(k) - scm_input%input_qv(k))
          end do
          scm_input%input_qi = 0.0
        end if !qi test
      end if !ql test
    else !qv, but not qt
      if (maxval(input_ql(active_lon,active_lat,:,active_init_time)) >= 0) then
        if (maxval(input_qi(active_lon,active_lat,:,active_init_time)) >= 0) then !qv, no qt, ql, qi
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_ql = input_ql(active_lon,active_lat,:,active_init_time)
          scm_input%input_qi = input_qi(active_lon,active_lat,:,active_init_time)
          !derive qt
          do k=1, input_n_lev
            scm_input%input_qt(k) = max(0.0, scm_input%input_qv(k) + scm_input%input_ql(k) + scm_input%input_qi(k))
          end do
        else !qv, no qt, ql, no qi
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_ql = input_ql(active_lon,active_lat,:,active_init_time)
          !derive qt
          do k=1, input_n_lev
            scm_input%input_qt(k) = max(0.0, scm_input%input_qv(k) + scm_input%input_ql(k))
          end do
          scm_input%input_qi = 0.0          
        end if ! qi test
      else
        if (maxval(input_qi(active_lon,active_lat,:,active_init_time)) >= 0) then !qv, no qt, no ql, qi
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_qi = input_qi(active_lon,active_lat,:,active_init_time)
          !derive qt
          do k=1, input_n_lev
            scm_input%input_qt(k) = max(0.0, scm_input%input_qv(k) + scm_input%input_qi(k))
          end do
          scm_input%input_ql = 0.0
        else !qv, no qt, no ql, no qi
          scm_input%input_qv = input_qv(active_lon,active_lat,:,active_init_time)
          scm_input%input_qt = scm_input%input_qv
          scm_input%input_ql = 0.0
          scm_input%input_qi = 0.0
        end if ! qi test
      end if ! ql test
    end if !qt test
  else if (maxval(input_qt(active_lon,active_lat,:,active_init_time)) >= 0) then !qt, but not qv
    if (maxval(input_ql(active_lon,active_lat,:,active_init_time)) >= 0) then
      if (maxval(input_qi(active_lon,active_lat,:,active_init_time)) >= 0) then !no qv, qt, ql, qi
        scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
        scm_input%input_ql = input_ql(active_lon,active_lat,:,active_init_time)
        scm_input%input_qi = input_qi(active_lon,active_lat,:,active_init_time)
        !derive qv
        do k=1, input_n_lev
          scm_input%input_qv(k) = max(0.0, scm_input%input_qt(k) - scm_input%input_ql(k) - scm_input%input_qi(k))
        end do
      else !no qv, qt, ql, no qi
        scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
        scm_input%input_ql = input_ql(active_lon,active_lat,:,active_init_time)
        !derive qv
        do k=1, input_n_lev
          scm_input%input_qv(k) = max(0.0, scm_input%input_qt(k) - scm_input%input_ql(k))
        end do
        scm_input%input_qi = 0.0
      end if
    else
      if (maxval(input_qi(active_lon,active_lat,:,active_init_time)) >= 0) then !no qv, qt, no ql, qi
        scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
        scm_input%input_qi = input_qi(active_lon,active_lat,:,active_init_time)
        !derive qv
        do k=1, input_n_lev
          scm_input%input_qv(k) = max(0.0, scm_input%input_qt(k) - scm_input%input_qi(k))
        end do
        scm_input%input_ql = 0.0
      else !no qv, qt, no ql, no qi
        scm_input%input_qt = input_qt(active_lon,active_lat,:,active_init_time)
        scm_input%input_qv = scm_input%input_qt
        scm_input%input_ql = 0.0
        scm_input%input_qi = 0.0
      end if
    end if !ql test
  else
    !no qv or qt
    write(*,*) 'When reading '//trim(adjustl(scm_state%case_name))//'.nc, all of the supported moisture variables (qv, qt, rv, rt) were missing. Stopping...'
    stop
  end if
  
  !make sure that at least one of temp, theta, thetal is present;
  !the priority for use is temp, thetal, theta
  if (maxval(input_temp(active_lon,active_lat,:,active_init_time)) > 0) then
    scm_input%input_temp = input_temp(active_lon,active_lat,:,active_init_time)
    !since temperature was present (and is ultimately needed in the physics), choose to use it, and set the alternative to missing, even if it is also present in the file
    scm_input%input_thetail = missing_value
  else if (maxval(input_thetal(active_lon,active_lat,:,active_init_time)) > 0) then
    !convert thetal to thetail
    do k=1, input_n_lev
      exner_inv = (p0/scm_input%input_pres(k))**con_rocp
      scm_input%input_thetail(k) = input_thetal(active_lon,active_lat,k,active_init_time) - &
        (con_hfus/con_cp)*exner_inv*(scm_input%input_qi(k)/(1.0 - scm_input%input_qi(k)))
    end do
    !since thetail is present, choose to use it, and set the alternative temperature to missing, even if it is also present in the file
    scm_input%input_temp = missing_value
  else if (maxval(input_theta(active_lon,active_lat,:,active_init_time)) > 0) then
    !convert theta to thetail
    do k=1, input_n_lev
      exner_inv = (p0/scm_input%input_pres(k))**con_rocp
      scm_input%input_thetail(k) = input_theta(active_lon,active_lat,k,active_init_time) - &
        (con_hvap/con_cp)*exner_inv*(scm_input%input_ql(k)/(1.0 - scm_input%input_ql(k))) - &
        (con_hfus/con_cp)*exner_inv*(scm_input%input_qi(k)/(1.0 - scm_input%input_qi(k)))
    end do
    !since thetail is present, choose to use it, and set the alternative temperature to missing, even if it is also present in the file
    scm_input%input_temp = missing_value
  else
    write(*,*) 'When reading '//trim(adjustl(scm_state%case_name))//'.nc, all of the supported temperature variables (temp, theta, thetal) were missing. Stopping...'
    stop
  end if
  
  !### what to do about ozone??? ### read in standard profile if not included in DEPHY file?
  scm_input%input_ozone = 0.0
  scm_input%input_lat = input_lat(active_lat)
  scm_input%input_lon = input_lon(active_lon)
  
  scm_input%input_pres_surf = input_force_pres_surf(active_lon,active_lat,:)
  
  do i=1, input_n_forcing_times
    scm_input%input_pres_forcing(i,:) = input_force_pres(active_lon,active_lat,:,i)
  end do
    
  if (input_SurfaceType == 'ocean') then
    scm_state%sfc_type = 0.0
  else if (input_SurfaceType == 'land') then
    scm_state%sfc_type = 1.0
  end if
  !no sea ice type?
  
  if (input_surfaceForcing == 'ts') then
    if (maxval(input_force_ts) < 0) then
      write(*,*) 'The global attribute surfaceForcing in '//trim(adjustl(scm_state%case_name))//'.nc indicates that the variable ts should be present, but it is missing. Stopping ...'
      stop
    else
      !overwrite sfc_flux_spec
      scm_state%sfc_flux_spec = .false.
      scm_input%input_T_surf = input_force_ts(active_lon,active_lat,:)
      scm_state%surface_thermo_control = 2
    end if
  else if (input_surfaceForcing == 'Flux') then
    !overwrite sfc_flux_spec
    scm_state%sfc_flux_spec = .true.
    scm_state%surface_thermo_control = 0
    
    if (maxval(input_force_ts) < 0) then
      !since no surface temperature is given, assume that the surface temperature is equivalent to the static, surface-adjacent temperature in the initial profile
      if (maxval(scm_input%input_temp) > 0) then
        !temperature profile is available
        scm_input%input_T_surf = scm_input%input_temp(1)
      else
        !ice-liquid potential temperature profile is available
        exner = (scm_input%input_pres(1)/p0)**con_rocp
        exner_inv = (p0/scm_input%input_pres(1))**con_rocp
        scm_input%input_T_surf = exner*(scm_input%input_thetail(1) + &
          (con_hvap/con_cp)*exner_inv*(scm_input%input_ql(1)/(1.0 - scm_input%input_ql(1))) + &
          (con_hfus/con_cp)*exner_inv*(scm_input%input_qi(1)/(1.0 - scm_input%input_qi(1))))
      end if
    else
      scm_input%input_T_surf = input_force_ts(active_lon,active_lat,:)
    end if
    
    !kinematic surface fluxes are specified (but may need to be converted)
    if (maxval(input_force_wpthetap(active_lon,active_lat,:)) < missing_value_eps) then
      write(*,*) 'The global attribute surfaceForcing in '//trim(adjustl(scm_state%case_name))//'.nc indicates that the variable wpthetap should be present, but it is missing. Stopping ...'
      stop
    else
      !convert from theta to T
      do i=1, input_n_forcing_times
        exner = (scm_input%input_pres_surf(i)/p0)**con_rocp
        scm_input%input_sh_flux_sfc_kin(i) = exner*input_force_wpthetap(active_lon,active_lat,i)
      end do
    end if
    
    !if mixing ratios are present, and not specific humidities, convert from mixing ratio to specific humidities
    if ((maxval(input_force_wpqvp(active_lon,active_lat,:)) < missing_value_eps .and. &
         maxval(input_force_wpqtp(active_lon,active_lat,:)) < missing_value_eps) .and. &
        (maxval(input_force_wprvp(active_lon,active_lat,:)) > missing_value_eps .or. &
         maxval(input_force_wprtp(active_lon,active_lat,:)) > missing_value_eps)) then
       if (maxval(input_force_wprvp(active_lon,active_lat,:)) > missing_value_eps) then
         do i=1, input_n_forcing_times
           input_force_wpqvp(active_lon,active_lat,i) = input_force_wprvp(active_lon,active_lat,i)/&
              (1.0 + input_force_wprvp(active_lon,active_lat,i))
         end do
       end if
       if (maxval(input_force_wprtp(active_lon,active_lat,:)) > missing_value_eps) then
         do i=1, input_n_forcing_times
           input_force_wpqtp(active_lon,active_lat,i) = input_force_wprtp(active_lon,active_lat,i)/&
              (1.0 + input_force_wprtp(active_lon,active_lat,i))
         end do
       end if
    end if
    
    if (maxval(input_force_wpqvp(active_lon,active_lat,:)) < missing_value_eps .and. maxval(input_force_wpqtp(active_lon,active_lat,:)) < missing_value_eps) then
      write(*,*) 'The global attribute surfaceForcing in '//trim(adjustl(scm_state%case_name))//'.nc indicates that the variable wpqvp, wpqtp, wprvp, or wprtp should be present, but all are missing. Stopping ...'
      stop
    else
      if (maxval(input_force_wpqvp(active_lon,active_lat,:)) > missing_value_eps) then !use wpqvp if available
        scm_input%input_lh_flux_sfc_kin = input_force_wpqvp(active_lon,active_lat,:)
      else
        !surface total flux of water should just be vapor
        scm_input%input_lh_flux_sfc_kin = input_force_wpqtp(active_lon,active_lat,:)
      end if
    end if
  else if (input_surfaceForcing == 'surfaceFlux') then
    !overwrite sfc_flux_spec
    scm_state%sfc_flux_spec = .true.
    scm_state%surface_thermo_control = 1
    
    if (maxval(input_force_ts) < 0) then
      !since no surface temperature is given, assume that the surface temperature is equivalent to the static, surface-adjacent temperature in the initial profile
      if (maxval(scm_input%input_temp) > 0) then
        !temperature profile is available
        scm_input%input_T_surf = scm_input%input_temp(1)
      else
        !ice-liquid potential temperature profile is available
        exner = (scm_input%input_pres(1)/p0)**con_rocp
        exner_inv = (p0/scm_input%input_pres(1))**con_rocp
        scm_input%input_T_surf = exner*(scm_input%input_thetail(1) + &
          (con_hvap/con_cp)*exner_inv*(scm_input%input_ql(1)/(1.0 - scm_input%input_ql(1))) + &
          (con_hfus/con_cp)*exner_inv*(scm_input%input_qi(1)/(1.0 - scm_input%input_qi(1))))
      end if
    else
      scm_input%input_T_surf = input_force_ts(active_lon,active_lat,:)
    end if
    
    
    if (maxval(input_force_sfc_sens_flx(active_lon,active_lat,:)) < missing_value_eps) then
      write(*,*) 'The global attribute surfaceForcing in '//trim(adjustl(scm_state%case_name))//'.nc indicates that the variable sfc_sens_flx should be present, but it is missing. Stopping ...'
      stop
    else
      scm_input%input_sh_flux_sfc = input_force_sfc_sens_flx(active_lon,active_lat,:)
    end if
    
    if (maxval(input_force_sfc_lat_flx(active_lon,active_lat,:)) < missing_value_eps) then
      write(*,*) 'The global attribute surfaceForcing in '//trim(adjustl(scm_state%case_name))//'.nc indicates that the variable sfc_lat_flx should be present, but it is missing. Stopping ...'
      stop
    else
      scm_input%input_lh_flux_sfc = input_force_sfc_lat_flx(active_lon,active_lat,:)
    end if
  end if
  
  if (input_surfaceForcingWind == 'z0') then
    scm_state%surface_momentum_control = 0
    scm_state%sfc_roughness_length_cm = input_z0*100.0 !convert from m to cm
  else if (input_surfaceForcingWind == 'ustar') then
    !not supported
    scm_state%surface_momentum_control = 1
    write(*,*) 'The global attribute surfaceForcingWind in '//trim(adjustl(scm_state%case_name))//'.nc indicates that surface wind is controlled by a specified time-series of ustar. This is currently not supported. Stopping ...'
    stop
  end if
  
  if (forc_omega > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_omega(i,:) = input_force_omega(active_lon,active_lat,:,i)
    end do
    scm_state%force_omega = .true.
    scm_state%force_w = .false. ! only one of forc_w, forc_omega should be true, with forc_omega having higher priority
    !set all individual w forcing controls to .true. until finer control is available from the input file
    scm_state%force_sub_for_T = .true.
    scm_state%force_sub_for_qv = .true.
    scm_state%force_sub_for_u = .true.
    scm_state%force_sub_for_v = .true.
  else if (forc_w > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_w_ls(i,:) = input_force_w(active_lon,active_lat,:,i)
    end do
    scm_state%force_w = .true.
    scm_state%force_omega = .false.
    !set all individual w forcing controls to .true. until finer control is available from the input file
    scm_state%force_sub_for_T = .true.
    scm_state%force_sub_for_qv = .true.
    scm_state%force_sub_for_u = .true.
    scm_state%force_sub_for_v = .true.
  end if

  if (forc_geo > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_u_g(i,:) = input_force_u_g(active_lon,active_lat,:,i)
      scm_input%input_v_g(i,:) = input_force_v_g(active_lon,active_lat,:,i)
    end do
    scm_state%force_geo = .true.
  end if
  
  if (adv_temp > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_T(i,:) = input_force_temp_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_T = 1
  else if (adv_theta > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_theta(i,:) = input_force_theta_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_T = 2
  else if (adv_thetal > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_thetal(i,:) = input_force_thetal_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_T = 3
  end if
  
  if (adv_qv > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_qv(i,:) = input_force_qv_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_qv = .true.
  else if (adv_qt > 0) then
    !since there is no information about individual advected species, assume it is all vapor
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_qv(i,:) = input_force_qt_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_qv = .true.
  else if (adv_rv > 0 .or. adv_rt > 0) then
    !convert to specific humidity
    if (adv_rv > 0) then
      do i=1, input_n_forcing_times
        do k=1, input_n_lev
          scm_input%input_tot_advec_qv(i,k) = input_force_rv_adv(active_lon,active_lat,k,i)/&
            (1.0 + input_force_rv_adv(active_lon,active_lat,k,i))
        end do
      end do
    else if (adv_rt > 0) then
      !since there is no information about individual advected species, assume it is all vapor
      do i=1, input_n_forcing_times
        do k=1, input_n_lev
          scm_input%input_tot_advec_qv(i,k) = input_force_rt_adv(active_lon,active_lat,k,i)/&
            (1.0 + input_force_rt_adv(active_lon,active_lat,k,i))
        end do
      end do
    end if
    scm_state%force_adv_qv = .true.
  end if
  
  if (adv_u > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_u(i,:) = input_force_u_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_u = .true.
  end if
  
  if (adv_v > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_tot_advec_v(i,:) = input_force_v_adv(active_lon,active_lat,:,i)
    end do
    scm_state%force_adv_v = .true.
  end if
  
  if (char_rad_temp == 'adv' .or. char_rad_theta == 'adv' .or. char_rad_thetal == 'adv') then
    scm_state%force_rad_T = 4
    if (scm_state%force_adv_T == 0) then
      write(*,*) 'The global attribute rad_temp, rad_theta, or rad_thetal in '//trim(adjustl(scm_state%case_name))//'.nc indicates that radiative forcing is included in the advection term, but there is no advection term. Stopping ...'
      stop
    end if
  else if (rad_temp > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_dT_dt_rad(i,:) = input_force_temp_rad(active_lon,active_lat,:,i)
    end do
    scm_state%force_rad_T = 1
  else if (rad_theta > 0) then
    scm_state%force_rad_T = 2
    do i=1, input_n_forcing_times
      do k=1, input_n_lev
        exner = (scm_input%input_pres(k)/p0)**con_rocp
        scm_input%input_dT_dt_rad(i,k) = exner*input_force_theta_rad(active_lon,active_lat,k,i)
      end do
    end do
  else if (rad_thetal > 0) then
    scm_state%force_rad_T = 3
    do i=1, input_n_forcing_times
      do k=1, input_n_lev
        exner = (scm_input%input_pres(k)/p0)**con_rocp
        scm_input%input_dT_dt_rad(i,k) = exner*input_force_thetal_rad(active_lon,active_lat,k,i)
      end do
    end do
  else
    scm_state%force_rad_T = 0
  end if
  
  if (nudging_temp > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_T_nudge(i,:) = input_force_temp_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_T = 1
    scm_state%force_nudging_T_time = nudging_temp
    if (p_nudging_temp > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_temp, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_T_nudge(i))
        if (scm_input%input_k_T_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_T_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_temp > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_temp, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_T_nudge(i))
        if (scm_input%input_k_T_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_T_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_T_nudge = 1
    end if
  else if (nudging_theta > 0) then
    !assume no cloud water since there is no associate [ql,qi]_nudge in the input?
    do i=1, input_n_forcing_times
      scm_input%input_thil_nudge(i,:) = input_force_theta_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_T = 2
    scm_state%force_nudging_T_time = nudging_theta
    if (p_nudging_theta > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_theta, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_thil_nudge(i))
        if (scm_input%input_k_thil_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_thil_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_theta > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_theta, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_thil_nudge(i))
        if (scm_input%input_k_thil_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_thil_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_thil_nudge = 1
    end if
  else if (nudging_thetal > 0) then
    !assume no cloud water since there is no associate [ql,qi]_nudge in the input?
    do i=1, input_n_forcing_times
      scm_input%input_thil_nudge(i,:) = input_force_thetal_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_T = 3
    scm_state%force_nudging_T_time = nudging_thetal
    if (p_nudging_thetal > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_thetal, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_thil_nudge(i))
        if (scm_input%input_k_thil_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_thil_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_thetal > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_thetal, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_thil_nudge(i))
        if (scm_input%input_k_thil_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_thil_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_thil_nudge = 1
    end if
  end if
  
  if (nudging_qv > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_qt_nudge(i,:) = input_force_qv_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_qv = .true.
    scm_state%force_nudging_qv_time = nudging_qv
    if (p_nudging_qv > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_qv, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_qv > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_qv, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_qt_nudge = 1
    end if
  else if (nudging_qt > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_qt_nudge(i,:) = input_force_qt_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_qv = .true.
    scm_state%force_nudging_qv_time = nudging_qt
    if (p_nudging_qt > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_qt, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_qt > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_qt, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_qt_nudge = 1
    end if
  else if (nudging_rv > 0) then
    do i=1, input_n_forcing_times
      do k=1, input_n_lev
        scm_input%input_qt_nudge(i,:) = input_force_rv_nudging(active_lon,active_lat,:,i)/&
          (1.0 + input_force_rv_nudging(active_lon,active_lat,:,i))
      end do
    end do
    scm_state%force_nudging_qv = .true.
    scm_state%force_nudging_qv_time = nudging_rv
    if (p_nudging_rv > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_rv, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_rv > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_rv, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_qt_nudge = 1
    end if
  else if (nudging_rt > 0) then
    do i=1, input_n_forcing_times
      do k=1, input_n_lev
        scm_input%input_qt_nudge(i,:) = input_force_rt_nudging(active_lon,active_lat,:,i)/&
          (1.0 + input_force_rt_nudging(active_lon,active_lat,:,i))
      end do
    end do
    scm_state%force_nudging_qv = .true.
    scm_state%force_nudging_qv_time = nudging_rt
    if (p_nudging_rt > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_rt, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_rt > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_rt, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_qt_nudge(i))
        if (scm_input%input_k_qt_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_qt_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_qt_nudge = 1
    end if
  end if
  
  if (nudging_u > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_u_nudge(i,:) = input_force_u_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_u = .true.
    scm_state%force_nudging_u_time = nudging_u
    if (p_nudging_u > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_u, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_u_nudge(i))
        if (scm_input%input_k_u_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_u_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_u > 0) then 
      do i=1, input_n_forcing_times 
        call find_vertical_index_height(z_nudging_u, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_u_nudge(i))
        if (scm_input%input_k_u_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_u_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_u_nudge = 1
    end if
  end if
  
  if (nudging_v > 0) then
    do i=1, input_n_forcing_times
      scm_input%input_v_nudge(i,:) = input_force_v_nudging(active_lon,active_lat,:,i)
    end do
    scm_state%force_nudging_v = .true.
    scm_state%force_nudging_v_time = nudging_v
    if (p_nudging_v > 0) then
      do i=1, input_n_forcing_times
        call find_vertical_index_pressure(p_nudging_v, input_force_pres(active_lon,active_lat,:,i), scm_input%input_k_v_nudge(i))
        if (scm_input%input_k_v_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_v_nudge(i) = input_n_lev
        end if
      end do
    else if (z_nudging_v > 0) then 
      do i=1, input_n_forcing_times
        call find_vertical_index_height(z_nudging_v, input_force_height(active_lon,active_lat,:,i), scm_input%input_k_v_nudge(i))
        if (scm_input%input_k_v_nudge(i) < 0) then
          !if the vertical index is not found (when it is less than 0), set the nudging index to the top of the input profile so that nudging is turned off
          scm_input%input_k_v_nudge(i) = input_n_lev
        end if
      end do
    else
      scm_input%input_k_v_nudge = 1
    end if
  end if
  
end subroutine get_case_init_DEPHY

!> Subroutine to get reference profile to use above the case data (temporarily hard-coded profile)
subroutine get_reference_profile(scm_state, scm_reference)
  use scm_type_defs, only : scm_state_type, scm_reference_type
  use NetCDF_read, only: check
  
  type(scm_state_type), target, intent(in) :: scm_state
  type(scm_reference_type), target, intent(inout) :: scm_reference

  integer  :: nlev !< number of pressure levels in the reference profile
  real(kind=dp), allocatable :: pres(:)  !< reference profile pressure (Pa)
  real(kind=dp), allocatable :: T(:) !< reference profile temperature (K)
  real(kind=dp), allocatable :: qv(:) !< reference profile specific humidity (kg kg^-1)
  real(kind=dp), allocatable :: ozone(:) !< reference profile ozone concentration (kg kg^-1)

  integer :: i, ioerror
  character(len=120)                 :: line
  real :: dummy

  integer                           :: ncid, varID, allocate_status
  CHARACTER(LEN=nf90_max_name)      :: tmpName

  select case (scm_state%reference_profile_choice)
    case (1)
      open(unit=1, file=trim(adjustl(scm_state%reference_profile_dir))//'/'//'McCProfiles.dat', status='old', action='read', iostat=ioerror)
      if(ioerror /= 0) then
        write(*,*) 'There was an error opening the file McCprofiles.dat in the processed_case_input directory. &
          Error code = ',ioerror
        stop
      endif

      ! find number of records
      read(1, '(a)', iostat=ioerror) line !first line is header
      nlev = 0
      do
        read(1, '(a)', iostat=ioerror) line
        if (ioerror /= 0) exit
        nlev = nlev + 1
      end do

      allocate(pres(nlev), T(nlev), qv(nlev), ozone(nlev))

      rewind(1)
      read(1, '(a)', iostat=ioerror) line !first line is header
      do i=1, nlev
        read(1,'(5ES16.4)', iostat=ioerror) dummy, pres(i), T(i), qv(i), ozone(i)
      END DO
      close(1)
    case (2)
      call check(NF90_OPEN(trim(adjustl(scm_state%reference_profile_dir))//'/'//'mid_lat_summer_std.nc',nf90_nowrite,ncid))

      call check(NF90_INQ_DIMID(ncid,"height",varID))
      call check(NF90_INQUIRE_DIMENSION(ncid, varID, tmpName, nlev))

      !> - Allocate the dimension variables.
      allocate(pres(nlev), T(nlev), qv(nlev), ozone(nlev), stat=allocate_status)

      call check(NF90_INQ_VARID(ncid,"pressure",varID))
      call check(NF90_GET_VAR(ncid,varID,pres))
      call check(NF90_INQ_VARID(ncid,"temperature",varID))
      call check(NF90_GET_VAR(ncid,varID,T))
      call check(NF90_INQ_VARID(ncid,"q_v",varID))
      call check(NF90_GET_VAR(ncid,varID,qv))
      call check(NF90_INQ_VARID(ncid,"o3",varID))
      call check(NF90_GET_VAR(ncid,varID,ozone))

      call check(NF90_CLOSE(NCID=ncid))

  end select

  call scm_reference%create(nlev)

  scm_reference%ref_nlev = nlev
  scm_reference%ref_pres = pres
  scm_reference%ref_T = T
  scm_reference%ref_qv = qv
  scm_reference%ref_ozone = ozone

end subroutine get_reference_profile

!> Subroutine to get reference profile to use above the case data (temporarily hard-coded profile)
subroutine get_reference_profile_old(nlev, pres, T, qv, ozone)
  integer, intent(out)  :: nlev !< number of pressure levels in the reference profile
  real(kind=dp), allocatable, intent(out) :: pres(:)  !< reference profile pressure (Pa)
  real(kind=dp), allocatable, intent(out) :: T(:) !< reference profile temperature (K)
  real(kind=dp), allocatable, intent(out) :: qv(:) !< reference profile specific humidity (kg kg^-1)
  real(kind=dp), allocatable, intent(out) :: ozone(:) !< reference profile ozone concentration (kg kg^-1)

  !> \todo write a more sophisticated reference profile subroutine (can choose between reference profiles)

  !> - For the prototype, the 'McClatchey' sounding used in Jennifer Fletcher's code is hardcoded.
  nlev = 20

  allocate(pres(nlev), T(nlev), qv(nlev), ozone(nlev))

  pres = (/ 1030.0, 902.0, 802.0, 710.0, 628.0, 554.0, 487.0, 426.0, 372.0, 281.0, 209.0, 130.0, 59.5, 27.7, 13.2, 6.52, 3.33, &
    0.951, 0.0671, 0.000300 /)
  pres = pres*100.0

  T = (/ 294., 290., 285., 279., 273., 267., 261., 255., 248., 235., 222., 216., 218., 224., 234., 245., 258., 276., 218., 210. /)

  qv = (/ 11.75, 8.611, 6.047, 3.877, 2.363, 1.387, 0.9388, 0.6364, 0.4019, 0.1546, 0.01976, 0.004002, 0.003999, 0.004011, &
    0.004002, 0.004004, 0.003994, 0.003995, 0.003996, 0.004000 /)
  qv = qv*1.0E-3

  ozone = (/ 6., 6., 6., 6.2, 6.4, 6.6, 6.9, 7.5, 7.9, 9., 12., 19., 34., 30., 20., 9.2, 4.1, 0.43, 0.0086, 0.0000043 /)
  ozone = ozone*1.0E-5

end subroutine get_reference_profile_old

subroutine get_tracers(tracer_names, tracer_types)
  character(len=character_length), allocatable, intent(inout), dimension(:) :: tracer_names
  integer,                         allocatable, intent(inout), dimension(:) :: tracer_types

  character(len=*), parameter :: file_name = 'tracers.txt'

  character(len=100) :: name!, std_name, units
  integer            :: i, fu, rc, n_lines

  open (action='read', file=FILE_NAME, iostat=rc, newunit=fu)
    if (rc == 0) then
        n_lines = 0
        do
            read (fu, *, iostat=rc) name!, std_name, units
            if (rc /= 0) exit
            n_lines = n_lines + 1
        end do
        allocate(tracer_names(n_lines),tracer_types(n_lines))
        rewind(fu)
        do i=1,n_lines
            read (fu, *, iostat=rc) name!, std_name, units
            if (rc /= 0) exit
            tracer_names(i) = trim(name)
            tracer_types(i) = 0 ! temporary until SCM is configured to work with GOCART
        end do
    else
        write(*,'(a,i0)') 'There was an error opening the file ' // FILE_NAME // &
                          '; error code = ', rc
        stop
    end if

    close (fu)
end subroutine get_tracers

!> @}
!> @}
end module scm_input
